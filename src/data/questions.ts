import type { Question } from "@/types/quiz";

export const questions: Question[] = [
  {
    id: "Q001",
    section: "Accounts & Ownership",
    tags: ["accounts", "ownership"],
    difficulty: "foundation",
    prompt: "What does it mean for a program to ‘own’ an account?",
    choices: [
      "The program can spend the account’s lamports",
      "The program can sign for the account",
      "The program is allowed to mutate the account’s data",
      "The account is locked to the program’s runtime",
    ],
    answerIndex: 2,
    explanation:
      "Ownership is an access-control rule: only the owning program can write an account’s data (or change its size). Lamports are controlled by the system program and the account’s owner/authority patterns.",
    deepDive:
      "In Solana, ownership is about write authority over data, not key custody. Programs never hold private keys, and lamport movement is enforced by the system program or other program-specific rules.",
  },
  {
    id: "Q002",
    section: "Accounts & Ownership",
    tags: ["accounts", "lamports"],
    difficulty: "foundation",
    prompt: "Which statement about lamports is correct?",
    choices: [
      "Only the account owner program can move lamports",
      "Lamports can be moved by any program that has the account as writable",
      "Lamports are debited/credited only by the system program or program-defined rules",
      "Lamports are not part of account state",
    ],
    answerIndex: 2,
    explanation:
      "Lamport movements are enforced by the runtime and system program; other programs can only move lamports through allowed instructions (often via CPI to the system program).",
    deepDive:
      "Programs can implement transfers for tokens they control, but native lamports follow system program rules. Writable access alone doesn’t allow arbitrary lamport changes.",
  },
  {
    id: "Q003",
    section: "Accounts & Ownership",
    tags: ["accounts", "rent"],
    difficulty: "advanced",
    prompt: "Why do many programs require accounts to be rent-exempt?",
    choices: [
      "To avoid signature verification",
      "To ensure accounts won’t be reclaimed over time",
      "To reduce compute unit usage",
      "To allow CPI without permission",
    ],
    answerIndex: 1,
    explanation:
      "Rent-exemption ensures the account has enough lamports to persist without being reclaimed. Programs often rely on long-lived state.",
    deepDive:
      "Even as rent mechanics evolve, rent-exempt balances remain the standard for durable program state.",
  },
  {
    id: "Q004",
    section: "Accounts & Ownership",
    tags: ["accounts", "data"],
    difficulty: "advanced",
    prompt: "Which account data change is always permitted?",
    choices: [
      "Any program can write any account if it’s writable",
      "Only the owning program can mutate data",
      "Any signer can mutate any account they sign for",
      "Read-only accounts can be resized",
    ],
    answerIndex: 1,
    explanation:
      "The runtime enforces that only the owning program can change an account’s data (and generally its size).",
    deepDive:
      "This is the core safety invariant that enables parallelism and composability without global locks.",
  },
  {
    id: "Q005",
    section: "Accounts & Ownership",
    tags: ["accounts", "locking"],
    difficulty: "advanced",
    prompt: "What is the practical effect of declaring an account as writable in a transaction?",
    choices: [
      "It becomes a signer",
      "It gains higher compute limits",
      "It receives an exclusive write lock during execution",
      "It can be accessed by any program without passing it",
    ],
    answerIndex: 2,
    explanation:
      "Writable accounts are write-locked for the duration of the transaction, preventing parallel writes that would break consistency.",
    deepDive: "This is the foundation of Solana’s parallel execution model—explicit conflict sets.",
  },
  {
    id: "Q006",
    section: "Accounts & Ownership",
    tags: ["accounts", "sysvar"],
    difficulty: "foundation",
    prompt: "Sysvar accounts are best described as…",
    choices: [
      "Writable system accounts used for rent collection",
      "Read-only accounts containing network/runtime data",
      "User-created accounts for program configuration",
      "Special PDAs owned by the system program",
    ],
    answerIndex: 1,
    explanation:
      "Sysvars are read-only accounts maintained by the runtime containing metadata (clock, epoch schedule, rent, etc.).",
    deepDive: "They’re accessed like normal accounts but are populated by the runtime.",
  },
  {
    id: "Q007",
    section: "Accounts & Ownership",
    tags: ["accounts", "discriminator"],
    difficulty: "expert",
    prompt: "Why do many programs store an account discriminator at the start of account data?",
    choices: [
      "To reduce account size",
      "To prevent signature replay",
      "To identify account type/layout quickly",
      "To enable CPI",
    ],
    answerIndex: 2,
    explanation:
      "A discriminator lets programs safely parse the data by confirming the expected layout before deserialization.",
    deepDive: "Anchor formalizes this pattern, but it’s common across custom programs too.",
  },
  {
    id: "Q008",
    section: "Accounts & Ownership",
    tags: ["accounts", "serialization"],
    difficulty: "expert",
    prompt: "What is a typical reason to keep account data layouts fixed and versioned?",
    choices: [
      "To avoid paying priority fees",
      "To allow schema evolution without breaking old state",
      "To make accounts signer-authorized",
      "To reduce account locking",
    ],
    answerIndex: 1,
    explanation:
      "Fixed/versioned layouts enable safe migrations and backward compatibility when state evolves.",
    deepDive:
      "You can add version fields or migrate with new accounts to avoid breaking existing users.",
  },
  {
    id: "Q009",
    section: "Transactions & Instructions",
    tags: ["transactions", "accounts"],
    difficulty: "foundation",
    prompt: "Why must all accounts a transaction will touch be listed up front?",
    choices: [
      "To enable fee estimation",
      "To allow the runtime to precompute signatures",
      "To enable parallelism and lock ordering",
      "To reduce block size",
    ],
    answerIndex: 2,
    explanation:
      "The runtime uses the account list to lock and schedule transactions in parallel safely.",
    deepDive: "This up-front declaration is why Solana can scale without a global state lock.",
  },
  {
    id: "Q010",
    section: "Transactions & Instructions",
    tags: ["transactions", "instructions"],
    difficulty: "foundation",
    prompt: "An instruction in Solana consists of…",
    choices: [
      "Only an opcode",
      "Program ID + accounts list + instruction data",
      "Program ID + blockhash only",
      "Account list + signatures only",
    ],
    answerIndex: 1,
    explanation:
      "Each instruction targets a program and includes the accounts it will read/write plus arbitrary data for that program.",
    deepDive:
      "This structure makes Solana’s runtime generic; each program defines its own instruction schema.",
  },
  {
    id: "Q011",
    section: "Transactions & Instructions",
    tags: ["transactions", "atomicity"],
    difficulty: "advanced",
    prompt: "A Solana transaction with multiple instructions is…",
    choices: [
      "Partially applied if an instruction fails",
      "Atomic: all instructions succeed or the whole tx fails",
      "Committed instruction by instruction",
      "Only atomic on devnet",
    ],
    answerIndex: 1,
    explanation:
      "Transactions are atomic: if any instruction fails, all state changes are rolled back.",
    deepDive:
      "This makes multi-instruction flows safe but increases compute and account footprint.",
  },
  {
    id: "Q012",
    section: "Transactions & Instructions",
    tags: ["transactions", "signers"],
    difficulty: "advanced",
    prompt: "What is a signer in Solana?",
    choices: [
      "An account that must be writable",
      "An account whose signature was verified on the transaction",
      "An account owned by the system program",
      "An account that can be mutated by any program",
    ],
    answerIndex: 1,
    explanation:
      "A signer is simply an account whose signature is present and verified on the transaction.",
    deepDive: "Signers prove authorization, but ownership and writability still matter.",
  },
  {
    id: "Q013",
    section: "Transactions & Instructions",
    tags: ["transactions", "replay"],
    difficulty: "advanced",
    prompt: "Why does Solana require a recent blockhash in a transaction?",
    choices: [
      "To select the leader",
      "To prevent replay attacks and limit lifetime",
      "To enable parallelism",
      "To choose the fee payer",
    ],
    answerIndex: 1,
    explanation: "Recent blockhashes bound transaction validity and prevent indefinite replay.",
    deepDive: "Durable nonce accounts extend this lifetime for specific use cases.",
  },
  {
    id: "Q014",
    section: "Transactions & Instructions",
    tags: ["transactions", "nonce"],
    difficulty: "expert",
    prompt: "What is the primary purpose of a durable nonce account?",
    choices: [
      "Increase compute budget",
      "Allow transactions to stay valid longer than blockhash expiry",
      "Enable CPI",
      "Store program data",
    ],
    answerIndex: 1,
    explanation:
      "Durable nonces let you sign transactions ahead of time by using a nonce value instead of a recent blockhash.",
    deepDive: "Useful for offline signing or delayed submission.",
  },
  {
    id: "Q015",
    section: "Transactions & Instructions",
    tags: ["transactions", "size"],
    difficulty: "advanced",
    prompt: "Why can transactions exceed size limits without ALTs?",
    choices: [
      "They can’t; size is fixed",
      "They compress account keys automatically",
      "They use shorter program IDs",
      "They are segmented across multiple slots",
    ],
    answerIndex: 0,
    explanation: "Legacy transactions are size-limited; that’s why v0 + ALTs exist.",
    deepDive: "ALTs are the first major solution for large account lists.",
  },
  {
    id: "Q016",
    section: "Transactions & Instructions",
    tags: ["transactions", "priority"],
    difficulty: "advanced",
    prompt: "What does a Compute Budget instruction primarily control?",
    choices: [
      "Rent rate",
      "Number of signers",
      "Compute unit limit and unit price",
      "Blockhash lifetime",
    ],
    answerIndex: 2,
    explanation:
      "Compute Budget instructions let you set requested compute units and unit price (priority fee).",
    deepDive: "These influence scheduling and inclusion under congestion.",
  },
  {
    id: "Q017",
    section: "PDAs & Signers",
    tags: ["pda", "signing"],
    difficulty: "foundation",
    prompt: "What is a Program-Derived Address (PDA)?",
    choices: [
      "A keypair controlled by a program",
      "A deterministic address off the ed25519 curve",
      "A random address used for temporary state",
      "A validator’s vote account",
    ],
    answerIndex: 1,
    explanation:
      "PDAs are deterministic addresses derived from seeds + program ID and are intentionally off-curve.",
    deepDive: "Being off-curve ensures no private key exists for that address.",
  },
  {
    id: "Q018",
    section: "PDAs & Signers",
    tags: ["pda", "invoke_signed"],
    difficulty: "advanced",
    prompt: "How does a program ‘sign’ for a PDA?",
    choices: [
      "It generates a private key at runtime",
      "The runtime validates seeds + bump via invoke_signed",
      "It uses the fee payer’s signature",
      "It hashes the recent blockhash",
    ],
    answerIndex: 1,
    explanation:
      "The runtime allows the program to act as signer if it proves the PDA via seeds + bump in invoke_signed.",
    deepDive: "Programs don’t own keys; they prove derivation to receive signing authority.",
  },
  {
    id: "Q019",
    section: "PDAs & Signers",
    tags: ["pda", "security"],
    difficulty: "advanced",
    prompt: "If an attacker can guess the PDA seeds, what happens?",
    choices: [
      "They can sign for the PDA",
      "They can steal PDA funds",
      "They can recompute the address but still cannot sign",
      "They can change the program ID",
    ],
    answerIndex: 2,
    explanation:
      "Knowing seeds lets you derive the address, but only the owning program can sign via invoke_signed.",
    deepDive: "Security is enforced by the runtime, not by seed secrecy.",
  },
  {
    id: "Q020",
    section: "PDAs & Signers",
    tags: ["pda", "bump"],
    difficulty: "foundation",
    prompt: "Why do PDAs need a ‘bump’ seed?",
    choices: [
      "To increase compute budget",
      "To find a derivation that is off-curve",
      "To allow CPI",
      "To prevent rent collection",
    ],
    answerIndex: 1,
    explanation:
      "The bump is adjusted to find an address that is off the ed25519 curve (i.e., not a valid pubkey).",
    deepDive: "It’s a brute-force search for a safe PDA derivation.",
  },
  {
    id: "Q021",
    section: "PDAs & Signers",
    tags: ["pda", "design"],
    difficulty: "expert",
    prompt: "Which PDA design best reduces account contention?",
    choices: [
      "One global PDA for all users",
      "A PDA per user or per position",
      "A PDA per program version",
      "A PDA per validator",
    ],
    answerIndex: 1,
    explanation: "Per-user or per-position PDAs localize writes and maximize parallelism.",
    deepDive: "Account modeling is the performance strategy in Solana.",
  },
  {
    id: "Q022",
    section: "PDAs & Signers",
    tags: ["pda", "authority"],
    difficulty: "advanced",
    prompt: "Which is a common PDA authority pattern?",
    choices: [
      "PDA owns a token account; program signs via invoke_signed",
      "PDA holds a private key",
      "PDA can sign without program involvement",
      "PDA must be a signer in the outer transaction",
    ],
    answerIndex: 0,
    explanation:
      "Programs often set a PDA as token account owner, then sign on its behalf using invoke_signed.",
    deepDive: "This avoids private key custody while enabling program-controlled funds.",
  },
  {
    id: "Q023",
    section: "Programs & CPI",
    tags: ["cpi", "programs"],
    difficulty: "foundation",
    prompt: "What is CPI in Solana?",
    choices: [
      "A consensus protocol",
      "Calling another program from within a program",
      "The instruction data format",
      "The fee market",
    ],
    answerIndex: 1,
    explanation: "CPI is cross-program invocation—program-to-program calls within one transaction.",
    deepDive: "This is Solana’s composability primitive, similar to contract-to-contract calls.",
  },
  {
    id: "Q024",
    section: "Programs & CPI",
    tags: ["cpi", "privilege"],
    difficulty: "advanced",
    prompt: "What is a key CPI privilege rule?",
    choices: [
      "CPI can escalate signer privileges",
      "CPI can only pass along equal or lower privileges",
      "CPI ignores account metadata",
      "CPI always requires system program",
    ],
    answerIndex: 1,
    explanation:
      "Programs cannot arbitrarily escalate privileges in CPI; they can only pass along signers/writability they received.",
    deepDive: "This prevents privilege escalation across program boundaries.",
  },
  {
    id: "Q025",
    section: "Programs & CPI",
    tags: ["programs", "bpf"],
    difficulty: "foundation",
    prompt: "Solana programs are compiled to…",
    choices: ["WASM", "sBPF/ELF", "JVM bytecode", "LLVM IR"],
    answerIndex: 1,
    explanation:
      "On-chain programs are compiled to sBPF (Solana BPF) and deployed as ELF binaries.",
    deepDive: "The runtime verifies and executes these in a sandbox.",
  },
  {
    id: "Q026",
    section: "Programs & CPI",
    tags: ["programs", "upgrade"],
    difficulty: "advanced",
    prompt: "What enables upgradable programs on Solana?",
    choices: [
      "The system program",
      "The BPF Loader Upgradeable program",
      "The vote program",
      "The feature gate program",
    ],
    answerIndex: 1,
    explanation:
      "Upgradeable programs are managed by the BPF Loader Upgradeable program and an upgrade authority.",
    deepDive: "Program upgrades are themselves transactions controlled by the upgrade authority.",
  },
  {
    id: "Q027",
    section: "Programs & CPI",
    tags: ["programs", "ownership"],
    difficulty: "advanced",
    prompt: "Who can change an account’s owner?",
    choices: [
      "Any signer",
      "Only the current owner program (or system program during creation)",
      "Any program with CPI",
      "Only validators",
    ],
    answerIndex: 1,
    explanation:
      "The owner can be changed only by the current owner (or system program when creating/assigning).",
    deepDive: "This protects state from being hijacked by other programs.",
  },
  {
    id: "Q028",
    section: "Programs & CPI",
    tags: ["programs", "idl"],
    difficulty: "expert",
    prompt: "Why do many teams generate client SDKs from IDLs?",
    choices: [
      "To avoid account locking",
      "To ensure typed instruction encoding/decoding",
      "To reduce compute units",
      "To bypass signature checks",
    ],
    answerIndex: 1,
    explanation:
      "IDL-based clients provide typed, consistent instruction serialization, reducing client bugs.",
    deepDive: "Tools like Anchor/Codama automate this step.",
  },
  {
    id: "Q029",
    section: "Programs & CPI",
    tags: ["programs", "sysvars"],
    difficulty: "foundation",
    prompt: "How do programs typically access cluster metadata like slot/epoch?",
    choices: [
      "Through the system program",
      "Via sysvar accounts",
      "By reading RPC directly",
      "By calling the vote program",
    ],
    answerIndex: 1,
    explanation:
      "Programs read sysvar accounts passed into the instruction for clock/epoch/rent info.",
    deepDive: "Sysvars must be provided in the account list like any other account.",
  },
  {
    id: "Q030",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "locking"],
    difficulty: "foundation",
    prompt: "Solana’s parallelism is primarily enabled by…",
    choices: [
      "Speculative execution",
      "Account-level read/write locks",
      "Global optimistic concurrency",
      "Separate chains per program",
    ],
    answerIndex: 1,
    explanation:
      "The runtime can execute transactions in parallel when their write-locked accounts don’t overlap.",
    deepDive: "This makes account modeling the performance lever.",
  },
  {
    id: "Q031",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "design"],
    difficulty: "advanced",
    prompt: "Which account design best improves parallel throughput?",
    choices: [
      "One global state account for all users",
      "Sharded state: one account per user or per market",
      "A PDA that stores all program state",
      "Store everything in sysvars",
    ],
    answerIndex: 1,
    explanation:
      "Sharding state into many accounts reduces write conflicts and unlocks parallelism.",
    deepDive: "Solana throughput is a direct function of account contention.",
  },
  {
    id: "Q032",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "rollback"],
    difficulty: "advanced",
    prompt: "If an instruction fails midway, what happens to account locks?",
    choices: [
      "Locks remain forever",
      "Locks are released and changes rolled back",
      "Locks are converted to read-only",
      "Locks are preserved for replay",
    ],
    answerIndex: 1,
    explanation: "The transaction is rolled back and locks are released once execution ends.",
    deepDive: "Atomicity guarantees consistency even under parallel execution.",
  },
  {
    id: "Q033",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "accounts"],
    difficulty: "foundation",
    prompt: "Read-only accounts…",
    choices: [
      "Are never locked",
      "Can be read in parallel by multiple transactions",
      "Can be written if a program decides",
      "Require a signer",
    ],
    answerIndex: 1,
    explanation:
      "Read-only accounts are shared-lockable, enabling parallel reads across transactions.",
    deepDive: "Write locks are exclusive; read locks can coexist.",
  },
  {
    id: "Q034",
    section: "Runtime & Parallelism",
    tags: ["compute", "units"],
    difficulty: "advanced",
    prompt: "Compute units (CUs) are best thought of as…",
    choices: [
      "Network bandwidth",
      "A rough measure of CPU work for a transaction",
      "Memory allocation size",
      "The number of accounts touched",
    ],
    answerIndex: 1,
    explanation:
      "Compute units measure execution cost; programs must stay within per-transaction limits.",
    deepDive: "You can request higher limits (and pay more) with Compute Budget instructions.",
  },
  {
    id: "Q035",
    section: "Runtime & Parallelism",
    tags: ["compute", "failure"],
    difficulty: "advanced",
    prompt: "What happens when a transaction exceeds its compute limit?",
    choices: [
      "It is paused and resumed in the next slot",
      "It is aborted and all state changes are rolled back",
      "The limit is automatically raised",
      "Only the last instruction fails",
    ],
    answerIndex: 1,
    explanation: "Exceeding the compute limit fails the transaction atomically.",
    deepDive: "This is why compute budgeting and optimization matter.",
  },
  {
    id: "Q036",
    section: "Runtime & Parallelism",
    tags: ["runtime", "syscalls"],
    difficulty: "expert",
    prompt: "Why are syscalls used in Solana programs?",
    choices: [
      "To bypass runtime safety checks",
      "To access runtime-provided functionality (hashes, sysvars, etc.)",
      "To perform network calls",
      "To increase priority fees",
    ],
    answerIndex: 1,
    explanation:
      "Syscalls expose runtime-provided capabilities to programs without direct OS access.",
    deepDive: "Examples: hash functions, logging, sysvar access, curve ops.",
  },
  {
    id: "Q037",
    section: "Fees & Compute Budget",
    tags: ["fees", "priority"],
    difficulty: "foundation",
    prompt: "Priority fees are…",
    choices: [
      "A flat fee paid to the system program",
      "An optional extra paid per compute unit",
      "Only required for vote transactions",
      "Paid in SPL tokens",
    ],
    answerIndex: 1,
    explanation:
      "Priority fees let users bid lamports per compute unit to improve inclusion during congestion.",
    deepDive: "They’re specified in Compute Budget instructions.",
  },
  {
    id: "Q038",
    section: "Fees & Compute Budget",
    tags: ["fees", "compute"],
    difficulty: "advanced",
    prompt: "Why might a transaction include a Compute Budget instruction?",
    choices: [
      "To reduce its account list",
      "To request a higher CU limit or set a unit price",
      "To bypass signature checks",
      "To access sysvars",
    ],
    answerIndex: 1,
    explanation: "Compute Budget lets you request more CUs and/or set a higher unit price.",
    deepDive: "This is crucial for heavy transactions under load.",
  },
  {
    id: "Q039",
    section: "Fees & Compute Budget",
    tags: ["fees", "payer"],
    difficulty: "foundation",
    prompt: "Who pays transaction fees on Solana?",
    choices: [
      "The program being called",
      "The fee payer account specified in the transaction",
      "The last writable account",
      "The validator leader",
    ],
    answerIndex: 1,
    explanation: "The fee payer is an explicit signer in the transaction.",
    deepDive: "Fee payer can be any signer, not necessarily the user who initiated the action.",
  },
  {
    id: "Q040",
    section: "Fees & Compute Budget",
    tags: ["fees", "cost"],
    difficulty: "advanced",
    prompt: "Which factor most directly increases transaction cost under fee markets?",
    choices: [
      "Number of instructions only",
      "Compute units requested and unit price",
      "Number of read-only accounts",
      "Presence of PDAs",
    ],
    answerIndex: 1,
    explanation: "Cost scales with requested compute units and the price per unit (priority fee).",
    deepDive: "This is separate from base fees.",
  },
  {
    id: "Q041",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "foundation",
    prompt: "What does the SPL Token program define?",
    choices: [
      "Consensus rules",
      "A standard for fungible tokens and associated accounts",
      "A wallet standard",
      "A fee market",
    ],
    answerIndex: 1,
    explanation: "SPL Token defines the on-chain standard for fungible tokens and token accounts.",
    deepDive: "It’s the equivalent of ERC-20 on Solana.",
  },
  {
    id: "Q042",
    section: "Token Programs",
    tags: ["tokens", "ata"],
    difficulty: "foundation",
    prompt: "What is an Associated Token Account (ATA)?",
    choices: [
      "A PDA that stores program data",
      "A deterministic token account derived from wallet + mint",
      "A validator-owned token account",
      "A sysvar",
    ],
    answerIndex: 1,
    explanation:
      "An ATA is a deterministic token account derived from a wallet address and a token mint.",
    deepDive: "It simplifies wallet UX by standardizing token account addresses.",
  },
  {
    id: "Q043",
    section: "Token Programs",
    tags: ["tokens", "authority"],
    difficulty: "advanced",
    prompt: "Which is a typical token authority pattern?",
    choices: [
      "Wallet owns token account; program signs for transfers",
      "PDA owns token account; program uses invoke_signed for transfers",
      "Token mint signs for transfers",
      "Sysvar owns token account",
    ],
    answerIndex: 1,
    explanation:
      "Program-controlled token accounts usually use a PDA as owner and invoke_signed for transfers.",
    deepDive: "This enables secure escrow and vault designs.",
  },
  {
    id: "Q044",
    section: "Token Programs",
    tags: ["token-2022", "extensions"],
    difficulty: "advanced",
    prompt: "Token-2022 primarily adds…",
    choices: [
      "A new consensus mechanism",
      "Extensions like transfer hooks, memo, metadata",
      "Mandatory KYC",
      "Faster finality",
    ],
    answerIndex: 1,
    explanation: "Token-2022 adds extensible features (transfer hooks, metadata, interest, etc.).",
    deepDive: "It’s a superset of SPL Token with optional extensions.",
  },
  {
    id: "Q045",
    section: "Token Programs",
    tags: ["token-2022", "compat"],
    difficulty: "advanced",
    prompt: "A common pitfall with Token-2022 is…",
    choices: [
      "It can’t be used with ATAs",
      "Clients must use the correct token program ID",
      "It doesn’t support minting",
      "It requires validator votes",
    ],
    answerIndex: 1,
    explanation: "Token-2022 uses a different program ID; clients must target the correct program.",
    deepDive: "Mixing program IDs causes signature/ownership failures.",
  },
  {
    id: "Q046",
    section: "Token Programs",
    tags: ["tokens", "mint"],
    difficulty: "foundation",
    prompt: "What does a token mint account store?",
    choices: [
      "All token balances",
      "Token metadata, decimals, and mint authority",
      "A list of all token accounts",
      "Only the token symbol",
    ],
    answerIndex: 1,
    explanation:
      "The mint stores global token configuration: decimals, supply, mint/freeze authorities.",
    deepDive: "Individual balances live in token accounts.",
  },
  {
    id: "Q047",
    section: "Token Programs",
    tags: ["tokens", "freeze"],
    difficulty: "expert",
    prompt: "What is the purpose of a freeze authority?",
    choices: [
      "To sign blockhashes",
      "To lock token accounts from transfers",
      "To change validator votes",
      "To disable CPI",
    ],
    answerIndex: 1,
    explanation: "A freeze authority can freeze token accounts to halt transfers for that mint.",
    deepDive: "Often used for compliance or emergency controls.",
  },
  {
    id: "Q048",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "v0"],
    difficulty: "foundation",
    prompt: "Why were versioned (v0) transactions introduced?",
    choices: [
      "To replace signatures",
      "To enable Address Lookup Tables and larger account lists",
      "To remove blockhashes",
      "To make programs upgradable",
    ],
    answerIndex: 1,
    explanation:
      "v0 transactions support ALTs, which compress account lists for large transactions.",
    deepDive: "This enables complex multi-program workflows.",
  },
  {
    id: "Q049",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "compression"],
    difficulty: "advanced",
    prompt: "How do ALTs reduce transaction size?",
    choices: [
      "By hashing instructions",
      "By storing addresses on-chain and referencing them by index",
      "By removing account metas",
      "By compressing signatures",
    ],
    answerIndex: 1,
    explanation:
      "ALTs store addresses on-chain so transactions can reference them by small indexes.",
    deepDive: "This reduces the byte cost of large account lists.",
  },
  {
    id: "Q050",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "authority"],
    difficulty: "advanced",
    prompt: "Who controls an ALT’s contents?",
    choices: [
      "Any program that references it",
      "Its authority (set at creation)",
      "The system program",
      "The fee payer",
    ],
    answerIndex: 1,
    explanation: "Each ALT has an authority that can extend, deactivate, or close it.",
    deepDive: "This prevents arbitrary tampering with lookup tables.",
  },
  {
    id: "Q051",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "use"],
    difficulty: "foundation",
    prompt: "Which transaction types can use ALTs?",
    choices: ["Legacy only", "v0 (versioned) only", "Both legacy and v0", "Only vote transactions"],
    answerIndex: 1,
    explanation: "ALTs are supported only in v0 (versioned) transactions.",
    deepDive: "Legacy transactions have fixed account list size limits.",
  },
  {
    id: "Q052",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "pitfall"],
    difficulty: "expert",
    prompt: "A common ALT pitfall is…",
    choices: [
      "You can’t use writable accounts",
      "You must include the ALT account itself in the tx message",
      "ALT addresses are mutable by anyone",
      "ALTs replace instruction data",
    ],
    answerIndex: 1,
    explanation:
      "The ALT account must be referenced in the transaction so the runtime can load it.",
    deepDive: "Missing the ALT account results in address resolution failures.",
  },
  {
    id: "Q053",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "slots"],
    difficulty: "foundation",
    prompt: "What does a slot represent in Solana?",
    choices: [
      "A finalized block",
      "A leader’s time window to produce a block",
      "A validator vote",
      "A single transaction",
    ],
    answerIndex: 1,
    explanation: "A slot is a period where a designated leader is expected to produce a block.",
    deepDive: "Slots create the schedule for block production.",
  },
  {
    id: "Q054",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "ordering"],
    difficulty: "advanced",
    prompt: "Proof of History (PoH) primarily provides…",
    choices: [
      "Finality",
      "A verifiable ordering of events",
      "Validator slashing",
      "Stake delegation",
    ],
    answerIndex: 1,
    explanation:
      "PoH is a verifiable clock that orders events without requiring global consensus on time.",
    deepDive: "It helps validators verify ordering faster than recomputing from scratch.",
  },
  {
    id: "Q055",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "finality"],
    difficulty: "advanced",
    prompt: "What is the difference between ‘confirmed’ and ‘finalized’?",
    choices: [
      "Confirmed is irreversible; finalized is reversible",
      "Finalized has stronger consensus weight and is very unlikely to revert",
      "They are identical",
      "Confirmed means all validators signed",
    ],
    answerIndex: 1,
    explanation:
      "Finalized has stronger BFT consensus weight and is extremely unlikely to revert compared to confirmed.",
    deepDive: "Use finalized for high-value actions; confirmed is often fine for UX.",
  },
  {
    id: "Q056",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "votes"],
    difficulty: "advanced",
    prompt: "What role do vote accounts play?",
    choices: [
      "They store token balances",
      "They cast votes on forks and earn rewards",
      "They store program data",
      "They track ALTs",
    ],
    answerIndex: 1,
    explanation:
      "Vote accounts are used by validators to vote on the fork choice and collect rewards.",
    deepDive: "Stake weight and voting drive consensus.",
  },
  {
    id: "Q057",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "stake"],
    difficulty: "foundation",
    prompt: "Consensus weight in Solana is primarily based on…",
    choices: ["Compute units", "Stake weight", "Number of transactions", "CPU cores"],
    answerIndex: 1,
    explanation: "Stake weight determines voting power and leader schedule priority.",
    deepDive: "This is standard for PoS systems.",
  },
  {
    id: "Q058",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "security"],
    difficulty: "expert",
    prompt: "PoH does NOT directly guarantee…",
    choices: [
      "Event ordering",
      "A cryptographic clock",
      "Whether a leader is honest about when they saw transactions",
      "Faster verification",
    ],
    answerIndex: 2,
    explanation:
      "PoH provides ordering and a clock, but it doesn’t prove when a leader actually received a transaction.",
    deepDive: "This is why MEV and leader control are still relevant.",
  },
  {
    id: "Q059",
    section: "Validator Pipeline & Networking",
    tags: ["tpu", "network"],
    difficulty: "foundation",
    prompt: "The TPU (Transaction Processing Unit) is responsible for…",
    choices: [
      "Voting",
      "Receiving and processing incoming transactions",
      "Storing snapshots",
      "Gossiping cluster info only",
    ],
    answerIndex: 1,
    explanation: "The TPU ingests transactions, validates them, and schedules execution.",
    deepDive: "It’s the hot path for transaction entry.",
  },
  {
    id: "Q060",
    section: "Validator Pipeline & Networking",
    tags: ["tvu", "network"],
    difficulty: "advanced",
    prompt: "The TVU (Transaction Validation Unit) primarily handles…",
    choices: [
      "Transaction ingestion",
      "Block verification and replay",
      "Fee estimation",
      "Account creation",
    ],
    answerIndex: 1,
    explanation: "The TVU verifies and replays blocks produced by leaders to update state.",
    deepDive: "This keeps validators in sync with the ledger.",
  },
  {
    id: "Q061",
    section: "Validator Pipeline & Networking",
    tags: ["quic", "qos"],
    difficulty: "advanced",
    prompt: "Why was QUIC adopted for transaction ingestion?",
    choices: [
      "It allows smart contracts",
      "It provides better flow control and resilience under load",
      "It removes signatures",
      "It speeds up PoH",
    ],
    answerIndex: 1,
    explanation: "QUIC improves flow control and robustness for packetized transaction ingest.",
    deepDive: "It helps reduce spam impact and improves stability.",
  },
  {
    id: "Q062",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "stake"],
    difficulty: "advanced",
    prompt: "Stake-weighted QoS means…",
    choices: [
      "All packets are equal",
      "Traffic from staked validators/RPCs gets priority",
      "Only validators can submit transactions",
      "Fees are ignored",
    ],
    answerIndex: 1,
    explanation: "Stake-weighted QoS prioritizes packets from staked validators or their peers.",
    deepDive: "This improves spam resistance during congestion.",
  },
  {
    id: "Q063",
    section: "Validator Pipeline & Networking",
    tags: ["gossip", "cluster"],
    difficulty: "foundation",
    prompt: "What is gossip used for?",
    choices: [
      "Transaction execution",
      "Cluster information propagation",
      "Fee estimation",
      "Program upgrades",
    ],
    answerIndex: 1,
    explanation: "Gossip spreads cluster metadata like peer info and leader schedule.",
    deepDive: "It’s essential for decentralized discovery.",
  },
  {
    id: "Q064",
    section: "Validator Pipeline & Networking",
    tags: ["turbine", "shreds"],
    difficulty: "expert",
    prompt: "Turbine’s role is to…",
    choices: [
      "Sign transactions",
      "Efficiently broadcast blocks via shreds",
      "Compute fees",
      "Store snapshots",
    ],
    answerIndex: 1,
    explanation: "Turbine is Solana’s block propagation protocol using shreds.",
    deepDive: "It reduces bandwidth requirements compared to naive broadcast.",
  },
  {
    id: "Q065",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "foundation",
    prompt: "Commitment levels in RPC allow clients to…",
    choices: [
      "Choose token programs",
      "Select how finalized the queried data should be",
      "Set compute limits",
      "Bypass fees",
    ],
    answerIndex: 1,
    explanation: "Commitment levels control how finalized/confirmed the data should be.",
    deepDive: "Clients can trade speed for finality.",
  },
  {
    id: "Q066",
    section: "RPC & Client Behavior",
    tags: ["rpc", "simulation"],
    difficulty: "advanced",
    prompt: "Why simulate transactions before sending?",
    choices: [
      "To bypass fees",
      "To detect errors and estimate logs/compute",
      "To finalize immediately",
      "To change the blockhash",
    ],
    answerIndex: 1,
    explanation: "Simulation reveals errors, logs, and compute usage without committing state.",
    deepDive: "It’s essential for debugging and fee tuning.",
  },
  {
    id: "Q067",
    section: "RPC & Client Behavior",
    tags: ["rpc", "websocket"],
    difficulty: "advanced",
    prompt: "When should you prefer WebSocket subscriptions over polling?",
    choices: [
      "Never",
      "When you need near-real-time account updates",
      "Only for token balances",
      "Only for vote accounts",
    ],
    answerIndex: 1,
    explanation: "WebSocket subscriptions deliver near-real-time updates without heavy polling.",
    deepDive: "This reduces RPC load and latency for live UX.",
  },
  {
    id: "Q068",
    section: "RPC & Client Behavior",
    tags: ["rpc", "retries"],
    difficulty: "advanced",
    prompt: "A robust client should retry on…",
    choices: [
      "All errors equally",
      "Transient errors like blockhash not found or node timeouts",
      "Only signature verification failures",
      "Only program errors",
    ],
    answerIndex: 1,
    explanation:
      "Transient network errors or blockhash expiry are common; retries with a fresh blockhash help.",
    deepDive: "Program errors should usually not be retried without changes.",
  },
  {
    id: "Q069",
    section: "RPC & Client Behavior",
    tags: ["rpc", "finality"],
    difficulty: "expert",
    prompt: "Why might a transaction be ‘confirmed’ but later not finalized?",
    choices: [
      "Confirmed is stronger than finalized",
      "Forks can still occur before finality thresholds are reached",
      "Validators ignore confirmed blocks",
      "Only on devnet",
    ],
    answerIndex: 1,
    explanation:
      "Confirmed data can still be on a fork that doesn’t reach finality; finalized is stronger.",
    deepDive: "This is rare but important for high-value operations.",
  },
  {
    id: "Q070",
    section: "RPC & Client Behavior",
    tags: ["rpc", "data"],
    difficulty: "foundation",
    prompt: "Account data fetched from RPC is…",
    choices: [
      "Always the final state",
      "Dependent on commitment level",
      "Encrypted",
      "Not affected by forks",
    ],
    answerIndex: 1,
    explanation:
      "RPC responses depend on commitment levels and can be affected by forks pre-finality.",
    deepDive: "Use higher commitment for critical reads.",
  },
  {
    id: "Q071",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "feature-gates"],
    difficulty: "advanced",
    prompt: "In Solana, when is a protocol change actually live?",
    choices: [
      "When a SIMD is merged",
      "When the validator release is published",
      "When the feature gate is activated on-chain",
      "When the docs update",
    ],
    answerIndex: 2,
    explanation:
      "The real switch is feature-gate activation; releases can ship code before activation.",
    deepDive: "This enables staged rollouts across clusters.",
  },
  {
    id: "Q072",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "process"],
    difficulty: "foundation",
    prompt: "What is a SIMD?",
    choices: [
      "A validator command",
      "A Solana Improvement Document proposal",
      "A token standard",
      "A consensus message",
    ],
    answerIndex: 1,
    explanation: "SIMDs are proposal documents describing protocol and ecosystem changes.",
    deepDive: "They track ideas through Review, Accepted, Implemented, Activated, etc.",
  },
  {
    id: "Q073",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "activation"],
    difficulty: "advanced",
    prompt: "Why use feature gates?",
    choices: [
      "To hide code from validators",
      "To activate changes safely and sequentially",
      "To skip testing",
      "To replace governance",
    ],
    answerIndex: 1,
    explanation:
      "Feature gates allow controlled activation of protocol changes with clear rollbacks.",
    deepDive: "They decouple code shipping from activation.",
  },
  {
    id: "Q074",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["release", "validator"],
    difficulty: "advanced",
    prompt: "Why might validators upgrade before a feature is active?",
    choices: [
      "They are forced to",
      "The feature is behind a gate and can be activated later",
      "Because it saves fees",
      "To change consensus rules immediately",
    ],
    answerIndex: 1,
    explanation:
      "Validators often upgrade to a version that includes gated features that activate later.",
    deepDive: "This is standard staged rollout practice.",
  },
  {
    id: "Q075",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["forks", "activation"],
    difficulty: "expert",
    prompt: "What’s a risk if validators activate a feature without network readiness?",
    choices: [
      "Nothing; activation is always safe",
      "Potential forks or instability if versions diverge",
      "Fees drop to zero",
      "Transactions become free",
    ],
    answerIndex: 1,
    explanation: "Activation before broad upgrade can cause divergence or instability.",
    deepDive: "This is why activation schedules are conservative.",
  },
  {
    id: "Q076",
    section: "Security & Pitfalls",
    tags: ["security", "signers"],
    difficulty: "foundation",
    prompt: "What is a common security pitfall in Solana programs?",
    choices: [
      "Checking account ownership and signer flags",
      "Failing to check account ownership/signers",
      "Using PDAs",
      "Using sysvars",
    ],
    answerIndex: 1,
    explanation: "Not validating ownership/signers can allow unauthorized mutations.",
    deepDive: "Always assert owners, signers, and expected addresses.",
  },
  {
    id: "Q077",
    section: "Security & Pitfalls",
    tags: ["security", "replay"],
    difficulty: "advanced",
    prompt: "Why include nonce or unique seeds in PDA derivations?",
    choices: [
      "To avoid rent",
      "To avoid address collisions",
      "To increase compute",
      "To enable CPI",
    ],
    answerIndex: 1,
    explanation: "Unique seeds ensure distinct PDAs per user/position and avoid collisions.",
    deepDive: "Deterministic uniqueness reduces state overlap.",
  },
  {
    id: "Q078",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "advanced",
    prompt: "A CPI pitfall is…",
    choices: [
      "Not passing required accounts",
      "Passing accounts with more privilege than allowed",
      "Assuming CPI can create new signers",
      "All of the above",
    ],
    answerIndex: 3,
    explanation:
      "CPI requires precise accounts and privilege rules; mistakes lead to failure or security issues.",
    deepDive: "CPI cannot magically elevate privileges.",
  },
  {
    id: "Q079",
    section: "Security & Pitfalls",
    tags: ["security", "logging"],
    difficulty: "foundation",
    prompt: "Why shouldn’t you treat logs as authoritative state?",
    choices: [
      "Logs are always encrypted",
      "Logs are hints, not canonical on-chain state",
      "Logs are mandatory for state changes",
      "Logs are only on devnet",
    ],
    answerIndex: 1,
    explanation: "Logs are for debugging/UX; canonical state lives in account data.",
    deepDive: "Build on account data, not log parsing.",
  },
  {
    id: "Q080",
    section: "Security & Pitfalls",
    tags: ["security", "reentrancy"],
    difficulty: "expert",
    prompt: "Solana programs are still vulnerable to reentrancy-like issues when…",
    choices: [
      "They call CPI to untrusted programs without state checks",
      "They use PDAs",
      "They use sysvars",
      "They are written in Rust",
    ],
    answerIndex: 0,
    explanation:
      "CPI to untrusted programs can introduce reentrancy-like patterns if state is not managed carefully.",
    deepDive: "Use checks-effects-interactions and account locks to mitigate.",
  },
  {
    id: "Q081",
    section: "Transactions & Instructions",
    tags: ["instructions", "order"],
    difficulty: "advanced",
    prompt: "Why does instruction order in a transaction matter?",
    choices: [
      "It never matters",
      "Later instructions can depend on state changes from earlier ones",
      "It only matters for sysvars",
      "It only matters for fees",
    ],
    answerIndex: 1,
    explanation:
      "Instructions execute sequentially; later instructions see state changes from earlier ones.",
    deepDive: "This enables complex atomic workflows.",
  },
  {
    id: "Q082",
    section: "Transactions & Instructions",
    tags: ["instructions", "accounts"],
    difficulty: "advanced",
    prompt: "If two instructions in one tx write the same account…",
    choices: [
      "It is not allowed",
      "It is allowed; they execute in order within the tx",
      "The account becomes read-only",
      "It must be a PDA",
    ],
    answerIndex: 1,
    explanation: "Within a transaction, multiple writes are allowed; the tx is atomic and ordered.",
    deepDive: "Parallelism is across transactions, not within a single one.",
  },
  {
    id: "Q083",
    section: "Transactions & Instructions",
    tags: ["instructions", "limits"],
    difficulty: "expert",
    prompt: "Why can large multi-instruction transactions still fail even with ALTs?",
    choices: [
      "ALTs increase compute",
      "Compute budget and account limits still apply",
      "ALTs only work on devnet",
      "They are rejected by wallets",
    ],
    answerIndex: 1,
    explanation: "ALTs solve address size, not compute or runtime limits.",
    deepDive: "Compute budget, CPI depth, and account limits still constrain complexity.",
  },
  {
    id: "Q084",
    section: "PDAs & Signers",
    tags: ["pda", "seeds"],
    difficulty: "advanced",
    prompt: "Which seed strategy is safest for a PDA?",
    choices: [
      "A single static seed",
      "User pubkey + program-specific constant",
      "Recent blockhash",
      "Validator identity",
    ],
    answerIndex: 1,
    explanation: "Combining user pubkey with a constant ensures stable, unique addresses per user.",
    deepDive: "Avoid ephemeral seeds that change unpredictably.",
  },
  {
    id: "Q085",
    section: "PDAs & Signers",
    tags: ["pda", "init"],
    difficulty: "advanced",
    prompt: "When initializing a PDA account, a typical pattern is…",
    choices: [
      "Program allocates and assigns via system program CPI",
      "Program directly writes to account data without create",
      "User signs for the PDA",
      "PDA signs for itself",
    ],
    answerIndex: 0,
    explanation: "Programs create PDA accounts via CPI to the system program, using invoke_signed.",
    deepDive: "This ensures proper lamports and ownership assignment.",
  },
  {
    id: "Q086",
    section: "Programs & CPI",
    tags: ["cpi", "accounts"],
    difficulty: "foundation",
    prompt: "If a program needs an account during CPI, it must…",
    choices: [
      "Read it from RPC",
      "Receive it from the caller as an account input",
      "Derive it internally without passing",
      "Use sysvars",
    ],
    answerIndex: 1,
    explanation:
      "Programs can only access accounts passed into the instruction (and in CPI, passed along).",
    deepDive: "No implicit access to global state.",
  },
  {
    id: "Q087",
    section: "Programs & CPI",
    tags: ["cpi", "signer"],
    difficulty: "advanced",
    prompt: "How can a program authorize a CPI that requires a signer?",
    choices: [
      "By setting the account to writable",
      "By using invoke_signed with PDA seeds",
      "By skipping signature checks",
      "By paying extra fees",
    ],
    answerIndex: 1,
    explanation: "invoke_signed provides PDA-based signing authority for CPI signers.",
    deepDive: "This is the core of PDA authority delegation.",
  },
  {
    id: "Q088",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why is ‘account list’ a scalability bottleneck for some apps?",
    choices: [
      "Because accounts are too small",
      "Because transaction size limits the number of accounts",
      "Because accounts must be encrypted",
      "Because account lists are random",
    ],
    answerIndex: 1,
    explanation: "Each account meta costs bytes; large workflows hit size limits without ALTs.",
    deepDive: "ALTs help, but compute and CPI depth still constrain complexity.",
  },
  {
    id: "Q089",
    section: "Runtime & Parallelism",
    tags: ["runtime", "determinism"],
    difficulty: "advanced",
    prompt: "Why must program execution be deterministic?",
    choices: [
      "To reduce fees",
      "So all validators reach the same state",
      "To allow PoH",
      "To improve UX",
    ],
    answerIndex: 1,
    explanation: "Determinism ensures all validators compute identical state transitions.",
    deepDive: "Non-determinism would split consensus.",
  },
  {
    id: "Q090",
    section: "Fees & Compute Budget",
    tags: ["compute", "budget"],
    difficulty: "expert",
    prompt: "Why might requesting too many compute units be counterproductive?",
    choices: [
      "It lowers your priority fee",
      "It increases cost and may reduce inclusion if too expensive",
      "It increases account limits",
      "It disables CPI",
    ],
    answerIndex: 1,
    explanation:
      "Requesting high compute increases cost; under congestion, it may reduce inclusion likelihood.",
    deepDive: "Tune compute/fee based on workload.",
  },
  {
    id: "Q091",
    section: "Token Programs",
    tags: ["tokens", "extensions"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions require extra account space?",
    choices: [
      "Because extension metadata is stored in the account",
      "Because extensions increase compute",
      "Because extensions add new PDAs",
      "Because extensions require sysvars",
    ],
    answerIndex: 0,
    explanation:
      "Extensions store additional data in the token account/mint, requiring extra space.",
    deepDive: "Account size must be allocated to fit extension state.",
  },
  {
    id: "Q092",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "advanced",
    prompt: "Why can a token transfer fail even if the sender has enough balance?",
    choices: [
      "Because token accounts are read-only",
      "Because the token program ID or authority is wrong",
      "Because of PoH",
      "Because CPI is not allowed",
    ],
    answerIndex: 1,
    explanation:
      "Common failures include wrong token program ID, missing signer, or frozen accounts.",
    deepDive: "Token transfers are authority-checked, not just balance-based.",
  },
  {
    id: "Q093",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "lifecycle"],
    difficulty: "advanced",
    prompt: "What happens when an ALT is deactivated?",
    choices: [
      "All transactions using it revert",
      "It can’t be extended and will expire after a cooldown",
      "It becomes read-only forever",
      "It loses all addresses immediately",
    ],
    answerIndex: 1,
    explanation: "Deactivation starts a cooldown period; after that it can be closed.",
    deepDive: "This prevents immediate removal that could break pending transactions.",
  },
  {
    id: "Q094",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "design"],
    difficulty: "expert",
    prompt: "Why do aggregators maintain multiple ALTs instead of one giant table?",
    choices: [
      "ALTs cannot exceed 5 addresses",
      "Different routes require different account sets; smaller ALTs reduce stale entries",
      "Because ALTs cost too many fees",
      "Because ALTs are validator-only",
    ],
    answerIndex: 1,
    explanation: "Route-specific ALTs keep tables focused and avoid unused/stale entries.",
    deepDive: "This improves reliability and reduces maintenance overhead.",
  },
  {
    id: "Q095",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "forks"],
    difficulty: "expert",
    prompt: "What causes a fork in Solana?",
    choices: [
      "A blockhash change",
      "Two leaders produce competing blocks for the same slot range",
      "A missing PDA",
      "RPC timeout",
    ],
    answerIndex: 1,
    explanation: "Forks occur when different validators see different valid blocks or sequences.",
    deepDive: "Consensus resolves forks based on stake-weighted votes.",
  },
  {
    id: "Q096",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "leader"],
    difficulty: "advanced",
    prompt: "How is the leader schedule determined?",
    choices: [
      "By random selection per transaction",
      "By stake-weighted deterministic schedule",
      "By fee payer",
      "By sysvar",
    ],
    answerIndex: 1,
    explanation: "Leader schedule is deterministic and stake-weighted over epochs.",
    deepDive: "This makes leader assignment predictable but weighted by stake.",
  },
  {
    id: "Q097",
    section: "Validator Pipeline & Networking",
    tags: ["shreds", "data"],
    difficulty: "advanced",
    prompt: "Why are blocks split into shreds?",
    choices: [
      "To hide data",
      "To enable efficient propagation and repair",
      "To reduce compute",
      "To simplify CPI",
    ],
    answerIndex: 1,
    explanation: "Shreds allow parallel distribution and repair of block data via Turbine.",
    deepDive: "It’s a key scalability mechanism.",
  },
  {
    id: "Q098",
    section: "Validator Pipeline & Networking",
    tags: ["repair", "turbine"],
    difficulty: "expert",
    prompt: "What is the purpose of repair in Solana’s networking?",
    choices: [
      "To allocate compute units",
      "To recover missing shreds and maintain ledger continuity",
      "To sign blocks",
      "To change leader schedule",
    ],
    answerIndex: 1,
    explanation:
      "Repair protocols fetch missing shreds to complete blocks and maintain ledger consistency.",
    deepDive: "This improves resilience under packet loss.",
  },
  {
    id: "Q099",
    section: "RPC & Client Behavior",
    tags: ["rpc", "indexing"],
    difficulty: "advanced",
    prompt: "Why do many production apps run their own indexers?",
    choices: [
      "Because RPC never works",
      "To build fast, app-specific queries beyond basic RPC",
      "To avoid writing programs",
      "To bypass fees",
    ],
    answerIndex: 1,
    explanation: "RPC is general-purpose; indexers provide fast, domain-specific queries.",
    deepDive: "This is similar to subgraphs or custom indexers on other chains.",
  },
  {
    id: "Q100",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "expert",
    prompt: "Why might ‘processed’ commitment be dangerous for user balances?",
    choices: [
      "It requires sysvars",
      "It can reflect forks that are not confirmed/finalized",
      "It is slower",
      "It costs more",
    ],
    answerIndex: 1,
    explanation: "Processed data can be on forks that never finalize; balances may revert.",
    deepDive: "Use confirmed/finalized for critical reads.",
  },
  {
    id: "Q101",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "clusters"],
    difficulty: "advanced",
    prompt: "Why are features activated on testnet before mainnet?",
    choices: [
      "To increase fees",
      "To validate behavior under realistic conditions",
      "To reduce compute",
      "To bypass governance",
    ],
    answerIndex: 1,
    explanation:
      "Staged activation reduces risk by validating changes under real load before mainnet.",
    deepDive: "This is standard in Solana’s rollout model.",
  },
  {
    id: "Q102",
    section: "Security & Pitfalls",
    tags: ["security", "pda"],
    difficulty: "expert",
    prompt: "A PDA collision (two different seed sets producing the same PDA) is…",
    choices: [
      "Common and expected",
      "Extremely unlikely unless intentionally engineered",
      "How PDAs are created",
      "A feature of PDAs",
    ],
    answerIndex: 1,
    explanation:
      "PDA collisions are practically impossible without deliberate construction attempts.",
    deepDive: "Seed choices should still be deterministic and unique.",
  },
  {
    id: "Q103",
    section: "Security & Pitfalls",
    tags: ["security", "accounts"],
    difficulty: "advanced",
    prompt: "Why should you verify account addresses explicitly?",
    choices: [
      "To reduce compute",
      "To prevent account substitution attacks",
      "To increase parallelism",
      "To avoid using PDAs",
    ],
    answerIndex: 1,
    explanation: "Attackers can pass arbitrary accounts; programs must enforce expected addresses.",
    deepDive: "Always check PDA derivations and owners.",
  },
  {
    id: "Q104",
    section: "Security & Pitfalls",
    tags: ["security", "init"],
    difficulty: "advanced",
    prompt: "What is a common initialization bug?",
    choices: [
      "Failing to set account data",
      "Re-initializing an already initialized account",
      "Using sysvars",
      "Using PDAs",
    ],
    answerIndex: 1,
    explanation: "Programs should guard against re-initialization to prevent state resets.",
    deepDive: "A discriminator or ‘is_initialized’ flag is typical.",
  },
  {
    id: "Q105",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "expert",
    prompt: "What does ‘signer privilege escalation’ mean in CPI context?",
    choices: [
      "Giving signer rights to an account that wasn’t a signer in the outer tx",
      "Using a PDA as signer",
      "Using system program",
      "Passing too many accounts",
    ],
    answerIndex: 0,
    explanation:
      "Signers can’t be escalated in CPI unless the program proves PDA authority via invoke_signed.",
    deepDive: "This protects users from unauthorized signing.",
  },
  {
    id: "Q106",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "commitment"],
    difficulty: "advanced",
    prompt: "Why might you wait for finalized status when bridging or settling?",
    choices: [
      "Because finalized can still revert",
      "Because finality reduces the risk of fork reorgs",
      "Because it increases fees",
      "Because it disables CPI",
    ],
    answerIndex: 1,
    explanation: "Finalized has stronger finality and much lower reorg risk.",
    deepDive: "Critical financial operations should wait for finalized.",
  },
  {
    id: "Q107",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "verification"],
    difficulty: "expert",
    prompt: "Why can PoH be verified faster than recomputed?",
    choices: [
      "Because validators skip hashes",
      "Because it’s a sequential hash chain with checkpoints/entries",
      "Because it uses GPUs only",
      "Because it’s randomized",
    ],
    answerIndex: 1,
    explanation:
      "PoH produces a sequential hash chain; verifying checkpoints is faster than recomputing all steps.",
    deepDive: "This enables efficient time-order verification.",
  },
  {
    id: "Q108",
    section: "Validator Pipeline & Networking",
    tags: ["leader", "mev"],
    difficulty: "expert",
    prompt: "Why can leaders influence transaction ordering?",
    choices: [
      "They can rewrite signatures",
      "They choose transaction ordering within their slot",
      "They control the system program",
      "They own all PDAs",
    ],
    answerIndex: 1,
    explanation: "Leaders decide ordering of transactions they include in their slots.",
    deepDive: "This is a source of MEV-like behavior.",
  },
  {
    id: "Q109",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "spam"],
    difficulty: "advanced",
    prompt: "How does stake-weighted QoS help under spam?",
    choices: [
      "It increases compute units",
      "It prioritizes packets from staked sources",
      "It removes fees",
      "It disables CPI",
    ],
    answerIndex: 1,
    explanation:
      "Stake-weighted QoS prefers traffic from staked validators/peers, reducing spam impact.",
    deepDive: "It’s a network-level defense.",
  },
  {
    id: "Q110",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why can two transactions touching the same writable account not run in parallel?",
    choices: [
      "Because of fee rules",
      "Because it would cause write-write conflicts",
      "Because of PoH",
      "Because of stake-weighted QoS",
    ],
    answerIndex: 1,
    explanation: "Write locks are exclusive; concurrent writes could break deterministic state.",
    deepDive: "Parallelism depends on non-overlapping write sets.",
  },
  {
    id: "Q111",
    section: "Token Programs",
    tags: ["tokens", "2022"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions complicate CPI?",
    choices: [
      "Extensions add extra required accounts/constraints",
      "Extensions remove signatures",
      "Extensions disable PDAs",
      "Extensions prevent ATAs",
    ],
    answerIndex: 0,
    explanation:
      "Extensions can require extra accounts or checks (e.g., transfer hooks), affecting CPI flows.",
    deepDive: "Clients and programs must include the right extra accounts.",
  },
  {
    id: "Q112",
    section: "Fees & Compute Budget",
    tags: ["fees", "market"],
    difficulty: "advanced",
    prompt: "What’s the best way to improve landing rate during congestion?",
    choices: [
      "Increase transaction size",
      "Add priority fee (unit price) and ensure compute budget is accurate",
      "Remove signatures",
      "Use sysvars",
    ],
    answerIndex: 1,
    explanation:
      "A reasonable priority fee and accurate compute budget improve inclusion likelihood.",
    deepDive: "Over-requesting compute can backfire by raising cost.",
  },
  {
    id: "Q113",
    section: "Versioned Transactions & ALTs",
    tags: ["v0", "wallets"],
    difficulty: "advanced",
    prompt: "Why might some wallets fail to sign a v0 transaction?",
    choices: [
      "They don’t support versioned txs",
      "They require PDAs",
      "They only support Token-2022",
      "They disallow sysvars",
    ],
    answerIndex: 0,
    explanation: "Older wallets might not support v0 transaction parsing/signing.",
    deepDive: "Most modern wallets now support v0, but compatibility matters.",
  },
  {
    id: "Q114",
    section: "Transactions & Instructions",
    tags: ["instructions", "data"],
    difficulty: "foundation",
    prompt: "Instruction data is…",
    choices: [
      "A fixed schema enforced by the runtime",
      "Arbitrary bytes interpreted by the program",
      "Always JSON",
      "Always an opcode",
    ],
    answerIndex: 1,
    explanation:
      "The runtime treats instruction data as opaque bytes; the program defines the schema.",
    deepDive: "This allows custom encoding strategies.",
  },
  {
    id: "Q115",
    section: "Programs & CPI",
    tags: ["programs", "logs"],
    difficulty: "foundation",
    prompt: "Program logs are best used for…",
    choices: ["Canonical state", "Debugging and UX hints", "Consensus voting", "Fee collection"],
    answerIndex: 1,
    explanation: "Logs help debugging and UX but are not canonical state.",
    deepDive: "State lives in accounts.",
  },
  {
    id: "Q116",
    section: "Programs & CPI",
    tags: ["programs", "compute"],
    difficulty: "advanced",
    prompt: "Why can a single extra CPI break an otherwise working tx?",
    choices: [
      "It changes the blockhash",
      "It increases compute and account requirements",
      "It disables PDAs",
      "It makes the tx invalid",
    ],
    answerIndex: 1,
    explanation: "CPI adds compute and often requires extra accounts; that can exceed limits.",
    deepDive: "Always budget compute and accounts for CPI chains.",
  },
  {
    id: "Q117",
    section: "Security & Pitfalls",
    tags: ["security", "account-substitution"],
    difficulty: "advanced",
    prompt: "Account substitution attacks occur when…",
    choices: [
      "Programs don’t verify expected addresses/owners",
      "Accounts are read-only",
      "Using sysvars",
      "Using PDAs",
    ],
    answerIndex: 0,
    explanation: "If programs accept arbitrary accounts, attackers can substitute malicious ones.",
    deepDive: "Always validate addresses, owners, and derivations.",
  },
  {
    id: "Q118",
    section: "Security & Pitfalls",
    tags: ["security", "rent"],
    difficulty: "advanced",
    prompt: "Why should you check account data length when deserializing?",
    choices: [
      "To reduce fees",
      "To avoid panics and ensure correct layout",
      "To increase compute",
      "To bypass ownership",
    ],
    answerIndex: 1,
    explanation: "Unexpected data length can cause deserialization errors or security issues.",
    deepDive: "Length checks prevent malformed data attacks.",
  },
  {
    id: "Q119",
    section: "RPC & Client Behavior",
    tags: ["rpc", "confirmations"],
    difficulty: "advanced",
    prompt: "Why should you re-fetch account state after a confirmed transaction?",
    choices: [
      "To update the recent blockhash",
      "To verify the actual on-chain state and handle forks",
      "To reduce fees",
      "To avoid CPI",
    ],
    answerIndex: 1,
    explanation: "Confirmation is not finality; re-fetch ensures you see the canonical state.",
    deepDive: "This is especially important for critical balances.",
  },
  {
    id: "Q120",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "status"],
    difficulty: "advanced",
    prompt: "Which SIMD status most closely implies ‘live on mainnet’?",
    choices: ["Implemented", "Activated", "Accepted", "Review"],
    answerIndex: 1,
    explanation: "Activated indicates the feature gate has been turned on and is live.",
    deepDive: "Implemented only means the code exists in a release.",
  },
];
