import type { Question } from "@/types/quiz";

export const questions: Question[] = [
  {
    id: "Q001",
    section: "Accounts & Ownership",
    tags: ["accounts", "ownership"],
    difficulty: "foundation",
    prompt: "What does it mean for a program to “own” an account?",
    choices: [
      "The program can sign for the account",
      "The program can always transfer lamports out of the account",
      "Only the program is allowed to write/resize the account’s data",
      "The account cannot be passed to other programs",
    ],
    answerIndex: 2,
    explanation:
      "Ownership is about write authority over account data (and typically resizing). It does not grant signing power, and it doesn’t imply the account can’t be used in CPI.",
    deepDive:
      "Think of owner as “who interprets and may mutate this data.” Signing is a transaction-level proof, and lamport movement is constrained by runtime rules and explicit authorization patterns.",
  },
  {
    id: "Q002",
    section: "Accounts & Ownership",
    tags: ["accounts", "lamports"],
    difficulty: "foundation",
    prompt: "Which statement about native lamports is most accurate?",
    choices: [
      "Any program can move lamports as long as the account is writable",
      "Only the account’s owner program can ever change its lamports",
      "Lamport changes are constrained by runtime invariants; user transfers require proper authorization (often via the system program)",
      "Lamports are stored only in sysvars, not in accounts",
    ],
    answerIndex: 2,
    explanation:
      "Lamports are part of account state, but the runtime enforces invariants and authorization. Writable alone doesn’t let arbitrary debits happen; typical wallet transfers follow system-program rules (signer/authority).",
    deepDive:
      "A good mental model: who may write data (owner), who authorizes actions (signers), and what state transitions are allowed (runtime + program rules) are separate axes.",
  },
  {
    id: "Q003",
    section: "Accounts & Ownership",
    tags: ["accounts", "rent"],
    difficulty: "advanced",
    prompt: "Why do many programs require accounts to be rent-exempt?",
    choices: [
      "To avoid signature verification",
      "To ensure accounts meet the minimum balance for durable state",
      "To reduce compute unit usage",
      "To allow CPI without permission",
    ],
    answerIndex: 1,
    explanation:
      "Programs often assume state must persist long-term. Rent-exempt funding is the common “durable state” convention and avoids rent-related edge cases or future policy changes.",
    deepDive:
      "Even if rent collection isn’t something most devs feel day-to-day, funding state accounts adequately remains best practice for long-lived protocol state.",
  },
  {
    id: "Q004",
    section: "Accounts & Ownership",
    tags: ["accounts", "data"],
    difficulty: "advanced",
    prompt: "Which account data change is always permitted?",
    choices: [
      "Any program can write any account if it’s writable",
      "Only the owning program can mutate data",
      "Any signer can mutate any account they sign for",
      "Read-only accounts can be resized",
    ],
    answerIndex: 1,
    explanation:
      "The runtime enforces that only the owning program can change an account’s data (and generally its size).",
    deepDive:
      "This is the core safety invariant that enables parallelism and composability without global locks.",
  },
  {
    id: "Q005",
    section: "Accounts & Ownership",
    tags: ["accounts", "locking"],
    difficulty: "advanced",
    prompt: "What is the practical effect of declaring an account as writable in a transaction?",
    choices: [
      "It becomes a signer",
      "It gains higher compute limits",
      "It receives an exclusive write lock during execution",
      "It can be accessed by any program without passing it",
    ],
    answerIndex: 2,
    explanation:
      "Writable accounts are write-locked for the duration of the transaction, preventing parallel writes that would break consistency.",
    deepDive: "This is the foundation of Solana’s parallel execution model—explicit conflict sets.",
  },
  {
    id: "Q006",
    section: "Accounts & Ownership",
    tags: ["accounts", "sysvar"],
    difficulty: "foundation",
    prompt: "Sysvar accounts are best described as…",
    choices: [
      "Writable system accounts used for rent collection",
      "Read-only accounts containing network/runtime data",
      "User-created accounts for program configuration",
      "Special PDAs owned by the system program",
    ],
    answerIndex: 1,
    explanation:
      "Sysvars are read-only accounts maintained by the runtime containing metadata (clock, epoch schedule, rent, etc.).",
    deepDive: "They’re accessed like normal accounts but are populated by the runtime.",
  },
  {
    id: "Q007",
    section: "Accounts & Ownership",
    tags: ["accounts", "discriminator"],
    difficulty: "expert",
    prompt: "Why do many programs store an account discriminator at the start of account data?",
    choices: [
      "To reduce account size",
      "To prevent signature replay",
      "To identify account type/layout quickly",
      "To enable CPI",
    ],
    answerIndex: 2,
    explanation:
      "A discriminator lets programs safely parse the data by confirming the expected layout before deserialization.",
    deepDive: "Anchor formalizes this pattern, but it’s common across custom programs too.",
  },
  {
    id: "Q008",
    section: "Accounts & Ownership",
    tags: ["accounts", "serialization"],
    difficulty: "expert",
    prompt: "What is a typical reason to keep account data layouts fixed and versioned?",
    choices: [
      "To avoid paying priority fees",
      "To allow schema evolution without breaking old state",
      "To make accounts signer-authorized",
      "To reduce account locking",
    ],
    answerIndex: 1,
    explanation:
      "Fixed/versioned layouts enable safe migrations and backward compatibility when state evolves.",
    deepDive:
      "You can add version fields or migrate with new accounts to avoid breaking existing users.",
  },
  {
    id: "Q009",
    section: "Transactions & Instructions",
    tags: ["transactions", "accounts"],
    difficulty: "foundation",
    prompt: "Why must all accounts a transaction will touch be listed up front?",
    choices: [
      "To enable fee estimation",
      "To allow the runtime to precompute signatures",
      "To enable parallelism and lock ordering",
      "To reduce block size",
    ],
    answerIndex: 2,
    explanation:
      "The runtime uses the account list to lock and schedule transactions in parallel safely.",
    deepDive: "This up-front declaration is why Solana can scale without a global state lock.",
  },
  {
    id: "Q010",
    section: "Transactions & Instructions",
    tags: ["transactions", "instructions"],
    difficulty: "foundation",
    prompt: "What uniquely defines an instruction (vs the whole transaction)?",
    choices: [
      "A fee payer + recent blockhash",
      "Program ID + account metas + instruction data",
      "A set of signatures over the message",
      "A list of all accounts touched across all programs",
    ],
    answerIndex: 1,
    explanation:
      "An instruction targets a single program and includes the accounts it will access plus arbitrary data interpreted by that program.",
    deepDive:
      "Transactions bundle instructions plus signatures, blockhash, and fee payer. Instructions are the runtime’s generic “call a program with these accounts and bytes.”",
  },
  {
    id: "Q011",
    section: "Transactions & Instructions",
    tags: ["transactions", "atomicity"],
    difficulty: "advanced",
    prompt: "A Solana transaction with multiple instructions is…",
    choices: [
      "Partially applied if an instruction fails",
      "Atomic: all instructions succeed or the whole tx fails",
      "Committed instruction by instruction",
      "Only atomic on devnet",
    ],
    answerIndex: 1,
    explanation:
      "Transactions are atomic: if any instruction fails, all state changes are rolled back.",
    deepDive:
      "This makes multi-instruction flows safe but increases compute and account footprint.",
  },
  {
    id: "Q012",
    section: "Transactions & Instructions",
    tags: ["transactions", "signers"],
    difficulty: "advanced",
    prompt: "What does it mean for an account to be marked as a signer in Solana?",
    choices: [
      "The account is writable",
      "The account’s private key signed the transaction message",
      "The account is owned by the system program",
      "The account can be mutated by any program",
    ],
    answerIndex: 1,
    explanation:
      "A signer is an account whose signature over the transaction message was verified. It says nothing by itself about ownership or writability.",
    deepDive:
      "Common bug: treating signer as allowed to write. On Solana these are orthogonal: signer proves authorization, owner controls data writes, and writability controls locking.",
  },
  {
    id: "Q013",
    section: "Transactions & Instructions",
    tags: ["transactions", "replay"],
    difficulty: "advanced",
    prompt: "Why does Solana require a recent blockhash in a transaction?",
    choices: [
      "To select the leader",
      "To prevent replay attacks and limit lifetime",
      "To enable parallelism",
      "To choose the fee payer",
    ],
    answerIndex: 1,
    explanation: "Recent blockhashes bound transaction validity and prevent indefinite replay.",
    deepDive: "Durable nonce accounts extend this lifetime for specific use cases.",
  },
  {
    id: "Q014",
    section: "Transactions & Instructions",
    tags: ["transactions", "nonce"],
    difficulty: "expert",
    prompt: "What is the primary purpose of a durable nonce account?",
    choices: [
      "Increase compute budget",
      "Allow transactions to stay valid longer than blockhash expiry",
      "Enable CPI",
      "Store program data",
    ],
    answerIndex: 1,
    explanation:
      "Durable nonces let you sign transactions ahead of time by using a nonce value instead of a recent blockhash.",
    deepDive: "Useful for offline signing or delayed submission.",
  },
  {
    id: "Q015",
    section: "Transactions & Instructions",
    tags: ["transactions", "size"],
    difficulty: "advanced",
    prompt: "Why do legacy transactions struggle with very large account lists?",
    choices: [
      "The message format has a hard size limit, and each account key costs bytes",
      "Legacy transactions cannot include more than one instruction",
      "Legacy transactions compress account keys automatically",
      "The runtime rejects transactions that touch more than 10 accounts",
    ],
    answerIndex: 0,
    explanation:
      "Legacy message size is limited and account keys dominate size. That’s why v0 transactions + ALTs exist: they reduce the byte cost of large account lists.",
    deepDive: "ALTs solve address bytes, not compute, CPI depth, or overall runtime limits.",
  },
  {
    id: "Q016",
    section: "Transactions & Instructions",
    tags: ["transactions", "priority"],
    difficulty: "advanced",
    prompt: "What does a Compute Budget instruction primarily control?",
    choices: [
      "Rent rate",
      "Number of signers",
      "Compute unit limit and unit price",
      "Blockhash lifetime",
    ],
    answerIndex: 2,
    explanation:
      "Compute Budget instructions let you set requested compute units and unit price (priority fee).",
    deepDive: "These influence scheduling and inclusion under congestion.",
  },
  {
    id: "Q017",
    section: "PDAs & Signers",
    tags: ["pda", "signing"],
    difficulty: "foundation",
    prompt: "What is a Program-Derived Address (PDA)?",
    choices: [
      "A deterministic address derived from seeds + program ID, designed so no private key exists for it",
      "A keypair generated deterministically by the program at runtime",
      "A special address that is automatically a signer in any transaction",
      "A validator-controlled account used for voting",
    ],
    answerIndex: 0,
    explanation:
      "PDAs are deterministic and derived from seeds + program ID; they’re constructed so they aren’t backed by a normal private key.",
    deepDive:
      "Programs don’t have keys. They prove PDA derivation (seeds + bump) to the runtime when they need PDA signing semantics.",
  },
  {
    id: "Q018",
    section: "PDAs & Signers",
    tags: ["pda", "invoke_signed"],
    difficulty: "advanced",
    prompt: "How does a program ‘sign’ for a PDA?",
    choices: [
      "It generates a private key at runtime",
      "The runtime validates seeds + bump via invoke_signed",
      "It uses the fee payer’s signature",
      "It hashes the recent blockhash",
    ],
    answerIndex: 1,
    explanation:
      "The runtime allows the program to act as signer if it proves the PDA via seeds + bump in invoke_signed.",
    deepDive: "Programs don’t own keys; they prove derivation to receive signing authority.",
  },
  {
    id: "Q019",
    section: "PDAs & Signers",
    tags: ["pda", "security"],
    difficulty: "advanced",
    prompt: "If an attacker can guess your PDA seeds, what is the real risk?",
    choices: [
      "They can sign for the PDA and drain funds",
      "They can derive the address, but still can’t sign; risk comes from your program’s missing address/owner/init checks",
      "They can change the PDA’s program ID and take ownership",
      "They can force the PDA to become on-curve and steal the private key",
    ],
    answerIndex: 1,
    explanation:
      "Seed knowledge lets anyone compute the address. That’s not enough to sign. The danger is when programs don’t validate expected addresses/owners/initialization and accept attacker-supplied accounts.",
    deepDive:
      "Defend with: derive expected PDA inside the program, compare addresses, check owner, check discriminator/init flags, and use canonical seeds.",
  },
  {
    id: "Q020",
    section: "PDAs & Signers",
    tags: ["pda", "bump"],
    difficulty: "foundation",
    prompt: "Why do PDAs need a ‘bump’ seed?",
    choices: [
      "To increase compute budget",
      "To find a derivation that is off-curve",
      "To allow CPI",
      "To prevent rent collection",
    ],
    answerIndex: 1,
    explanation:
      "The bump is adjusted to find an address that is off the ed25519 curve (i.e., not a valid pubkey).",
    deepDive: "It’s a brute-force search for a safe PDA derivation.",
  },
  {
    id: "Q021",
    section: "PDAs & Signers",
    tags: ["pda", "design"],
    difficulty: "expert",
    prompt: "Which PDA design best reduces account contention?",
    choices: [
      "One global PDA for all users",
      "A PDA per user or per position",
      "A PDA per program version",
      "A PDA per validator",
    ],
    answerIndex: 1,
    explanation: "Per-user or per-position PDAs localize writes and maximize parallelism.",
    deepDive: "Account modeling is the performance strategy in Solana.",
  },
  {
    id: "Q022",
    section: "PDAs & Signers",
    tags: ["pda", "authority"],
    difficulty: "advanced",
    prompt: "Which is a common PDA authority pattern?",
    choices: [
      "PDA owns a token account; program signs via invoke_signed",
      "PDA holds a private key",
      "PDA can sign without program involvement",
      "PDA must be a signer in the outer transaction",
    ],
    answerIndex: 0,
    explanation:
      "Programs often set a PDA as token account owner, then sign on its behalf using invoke_signed.",
    deepDive: "This avoids private key custody while enabling program-controlled funds.",
  },
  {
    id: "Q023",
    section: "Programs & CPI",
    tags: ["cpi", "programs"],
    difficulty: "foundation",
    prompt: "In CPI (cross-program invocation), what is the most important mental model?",
    choices: [
      "CPI lets a program call another program, but only with accounts/privileges it already has",
      "CPI lets a program fetch any account from RPC during execution",
      "CPI automatically makes the callee’s accounts writable",
      "CPI is only possible when both programs share the same upgrade authority",
    ],
    answerIndex: 0,
    explanation:
      "CPI is program-to-program calling within a transaction, but the caller cannot conjure accounts or privileges it wasn’t given.",
    deepDive:
      "This is the composability rule that prevents privilege escalation: everything the callee touches must be passed explicitly and must respect the outer transaction’s privileges.",
  },
  {
    id: "Q024",
    section: "Programs & CPI",
    tags: ["cpi", "privilege"],
    difficulty: "advanced",
    prompt: "What is a key CPI privilege rule?",
    choices: [
      "CPI can escalate signer privileges",
      "CPI can only pass along equal or lower privileges",
      "CPI ignores account metadata",
      "CPI always requires system program",
    ],
    answerIndex: 1,
    explanation:
      "Programs cannot arbitrarily escalate privileges in CPI; they can only pass along signers/writability they received.",
    deepDive: "This prevents privilege escalation across program boundaries.",
  },
  {
    id: "Q025",
    section: "Programs & CPI",
    tags: ["programs", "bpf"],
    difficulty: "foundation",
    prompt: "What do validators actually execute when they run a Solana program?",
    choices: [
      "The program’s Rust source code",
      "An sBPF (Solana BPF) ELF binary verified and run in a sandbox",
      "WebAssembly (WASM) bytecode",
      "JVM bytecode via a VM embedded in the validator",
    ],
    answerIndex: 1,
    explanation:
      "On-chain programs are compiled to sBPF and deployed as ELF; the runtime verifies and executes them in a sandbox.",
    deepDive:
      "This is why syscalls exist: programs can’t access OS primitives directly; they call into runtime-provided capabilities.",
  },
  {
    id: "Q026",
    section: "Programs & CPI",
    tags: ["programs", "upgrade"],
    difficulty: "advanced",
    prompt: "What enables upgradable programs on Solana?",
    choices: [
      "The system program",
      "The BPF Loader Upgradeable program",
      "The vote program",
      "The feature gate program",
    ],
    answerIndex: 1,
    explanation:
      "Upgradeable programs are managed by the BPF Loader Upgradeable program and an upgrade authority.",
    deepDive: "Program upgrades are themselves transactions controlled by the upgrade authority.",
  },
  {
    id: "Q027",
    section: "Programs & CPI",
    tags: ["programs", "ownership"],
    difficulty: "advanced",
    prompt: "Who can change an account’s owner?",
    choices: [
      "Any signer",
      "The system program, under its assign/create rules (with account authorization)",
      "Any program with CPI",
      "Only validators",
    ],
    answerIndex: 1,
    explanation:
      "Ownership is set/changed via system program instructions and requires the account to authorize the change. Programs can’t arbitrarily reassign accounts they don’t control.",
    deepDive: "In practice, ownership is usually set at creation and rarely changed afterward.",
  },
  {
    id: "Q028",
    section: "Programs & CPI",
    tags: ["programs", "idl"],
    difficulty: "expert",
    prompt: "Why do many teams generate client SDKs from IDLs?",
    choices: [
      "To avoid account locking",
      "To ensure typed instruction encoding/decoding",
      "To reduce compute units",
      "To bypass signature checks",
    ],
    answerIndex: 1,
    explanation:
      "IDL-based clients provide typed, consistent instruction serialization, reducing client bugs.",
    deepDive: "Tools like Anchor/Codama automate this step.",
  },
  {
    id: "Q029",
    section: "Programs & CPI",
    tags: ["programs", "sysvars"],
    difficulty: "foundation",
    prompt: "How do programs typically access cluster metadata like slot/epoch?",
    choices: [
      "Through the system program",
      "Via sysvar accounts",
      "By reading RPC directly",
      "By calling the vote program",
    ],
    answerIndex: 1,
    explanation:
      "Programs read sysvar accounts passed into the instruction for clock/epoch/rent info.",
    deepDive: "Sysvars must be provided in the account list like any other account.",
  },
  {
    id: "Q030",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "locking"],
    difficulty: "foundation",
    prompt: "Solana’s parallelism is primarily enabled by…",
    choices: [
      "Speculative execution",
      "Account-level read/write locks",
      "Global optimistic concurrency",
      "Separate chains per program",
    ],
    answerIndex: 1,
    explanation:
      "The runtime can execute transactions in parallel when their write-locked accounts don’t overlap.",
    deepDive: "This makes account modeling the performance lever.",
  },
  {
    id: "Q031",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "design"],
    difficulty: "advanced",
    prompt: "Which account design best improves parallel throughput?",
    choices: [
      "One global state account for all users",
      "Sharded state: one account per user or per market",
      "A PDA that stores all program state",
      "Store everything in sysvars",
    ],
    answerIndex: 1,
    explanation:
      "Sharding state into many accounts reduces write conflicts and unlocks parallelism.",
    deepDive: "Solana throughput is a direct function of account contention.",
  },
  {
    id: "Q032",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "rollback"],
    difficulty: "advanced",
    prompt: "If an instruction fails midway, what happens to account locks?",
    choices: [
      "Locks remain forever",
      "Locks are released and changes rolled back",
      "Locks are converted to read-only",
      "Locks are preserved for replay",
    ],
    answerIndex: 1,
    explanation: "The transaction is rolled back and locks are released once execution ends.",
    deepDive: "Atomicity guarantees consistency even under parallel execution.",
  },
  {
    id: "Q033",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "accounts"],
    difficulty: "foundation",
    prompt: "Read-only accounts in a transaction…",
    choices: [
      "Are not locked at all",
      "Use shared/read locks, allowing many concurrent readers across transactions",
      "Become writable if the program chooses",
      "Must be signers",
    ],
    answerIndex: 1,
    explanation:
      "Read-only accounts can be accessed in parallel by multiple transactions because they take shared/read locks. Only writable accounts take exclusive locks.",
    deepDive:
      "This is why marking accounts writable “just in case” harms throughput: you convert shared locks into exclusive conflicts.",
  },
  {
    id: "Q034",
    section: "Runtime & Parallelism",
    tags: ["compute", "units"],
    difficulty: "advanced",
    prompt: "Compute units (CUs) are best thought of as…",
    choices: [
      "Network bandwidth",
      "A rough measure of CPU work for a transaction",
      "Memory allocation size",
      "The number of accounts touched",
    ],
    answerIndex: 1,
    explanation:
      "Compute units measure execution cost; programs must stay within per-transaction limits.",
    deepDive: "You can request higher limits (and pay more) with Compute Budget instructions.",
  },
  {
    id: "Q035",
    section: "Runtime & Parallelism",
    tags: ["compute", "failure"],
    difficulty: "advanced",
    prompt: "What happens when a transaction exceeds its compute limit?",
    choices: [
      "It is paused and resumed in the next slot",
      "It is aborted and all state changes are rolled back",
      "The limit is automatically raised",
      "Only the last instruction fails",
    ],
    answerIndex: 1,
    explanation: "Exceeding the compute limit fails the transaction atomically.",
    deepDive: "This is why compute budgeting and optimization matter.",
  },
  {
    id: "Q036",
    section: "Runtime & Parallelism",
    tags: ["runtime", "syscalls"],
    difficulty: "expert",
    prompt: "Why are syscalls used in Solana programs?",
    choices: [
      "To bypass runtime safety checks",
      "To access runtime-provided functionality (hashes, sysvars, etc.)",
      "To perform network calls",
      "To increase priority fees",
    ],
    answerIndex: 1,
    explanation:
      "Syscalls expose runtime-provided capabilities to programs without direct OS access.",
    deepDive: "Examples: hash functions, logging, sysvar access, curve ops.",
  },
  {
    id: "Q037",
    section: "Fees & Compute Budget",
    tags: ["fees", "priority"],
    difficulty: "foundation",
    prompt: "Priority fees are…",
    choices: [
      "A flat fee paid to the system program",
      "An optional extra paid per compute unit",
      "Only required for vote transactions",
      "Paid in SPL tokens",
    ],
    answerIndex: 1,
    explanation:
      "Priority fees let users bid lamports per compute unit to improve inclusion during congestion.",
    deepDive: "They’re specified in Compute Budget instructions.",
  },
  {
    id: "Q038",
    section: "Fees & Compute Budget",
    tags: ["fees", "compute"],
    difficulty: "advanced",
    prompt: "Why might a transaction include a Compute Budget instruction?",
    choices: [
      "To reduce its account list",
      "To request a higher CU limit or set a unit price",
      "To bypass signature checks",
      "To access sysvars",
    ],
    answerIndex: 1,
    explanation: "Compute Budget lets you request more CUs and/or set a higher unit price.",
    deepDive: "This is crucial for heavy transactions under load.",
  },
  {
    id: "Q039",
    section: "Fees & Compute Budget",
    tags: ["fees", "payer"],
    difficulty: "foundation",
    prompt: "Who pays transaction fees on Solana?",
    choices: [
      "The program being called",
      "The fee payer account specified in the transaction",
      "The last writable account",
      "The validator leader",
    ],
    answerIndex: 1,
    explanation: "The fee payer is an explicit signer in the transaction.",
    deepDive: "Fee payer can be any signer, not necessarily the user who initiated the action.",
  },
  {
    id: "Q040",
    section: "Fees & Compute Budget",
    tags: ["fees", "cost"],
    difficulty: "advanced",
    prompt: "Which factor most directly increases transaction cost under fee markets?",
    choices: [
      "Number of instructions only",
      "Compute units requested and unit price",
      "Number of read-only accounts",
      "Presence of PDAs",
    ],
    answerIndex: 1,
    explanation: "Cost scales with requested compute units and the price per unit (priority fee).",
    deepDive: "This is separate from base fees.",
  },
  {
    id: "Q041",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "foundation",
    prompt: "What does the SPL Token program standardize on Solana?",
    choices: [
      "Consensus rules for validators",
      "Fungible token mint + token account state transitions (mint, transfer, burn, approve)",
      "Wallet seed phrase formats",
      "Transaction fee markets",
    ],
    answerIndex: 1,
    explanation: "It standardizes token mechanics and account layouts for fungible tokens.",
    deepDive:
      "Like ERC-20 in concept, but implemented via explicit accounts (mint + token accounts) and program-owned state.",
  },
  {
    id: "Q042",
    section: "Token Programs",
    tags: ["tokens", "ata"],
    difficulty: "foundation",
    prompt: "What makes an Associated Token Account (ATA) valuable for UX?",
    choices: [
      "It is the only type of token account that can hold SPL tokens",
      "It is a deterministic token account address for (wallet, mint, token program), so wallets can “find” balances predictably",
      "It is a sysvar maintained by the runtime",
      "It automatically signs transfers for the wallet",
    ],
    answerIndex: 1,
    explanation:
      "ATAs are deterministic, so clients don’t need discovery/indexing to locate the “standard” account for a wallet’s token balance.",
    deepDive:
      "The deterministic address idea is why ATAs reduce UX friction—but you still must use the correct token program (classic vs Token-2022).",
  },
  {
    id: "Q043",
    section: "Token Programs",
    tags: ["tokens", "authority"],
    difficulty: "advanced",
    prompt: "Which is a typical token authority pattern?",
    choices: [
      "Wallet owns token account; program signs for transfers",
      "PDA owns token account; program uses invoke_signed for transfers",
      "Token mint signs for transfers",
      "Sysvar owns token account",
    ],
    answerIndex: 1,
    explanation:
      "Program-controlled token accounts usually use a PDA as owner and invoke_signed for transfers.",
    deepDive: "This enables secure escrow and vault designs.",
  },
  {
    id: "Q044",
    section: "Token Programs",
    tags: ["token-2022", "extensions"],
    difficulty: "advanced",
    prompt: "Token-2022 primarily adds…",
    choices: [
      "A new consensus mechanism",
      "Extensions like transfer hooks, memo, metadata",
      "Mandatory KYC",
      "Faster finality",
    ],
    answerIndex: 1,
    explanation: "Token-2022 adds extensible features (transfer hooks, metadata, interest, etc.).",
    deepDive: "It’s a superset of SPL Token with optional extensions.",
  },
  {
    id: "Q045",
    section: "Token Programs",
    tags: ["token-2022", "compat"],
    difficulty: "advanced",
    prompt: "A common pitfall with Token-2022 is…",
    choices: [
      "It can’t be used with ATAs",
      "Clients must use the correct token program ID",
      "It doesn’t support minting",
      "It requires validator votes",
    ],
    answerIndex: 1,
    explanation: "Token-2022 uses a different program ID; clients must target the correct program.",
    deepDive: "Mixing program IDs causes signature/ownership failures.",
  },
  {
    id: "Q046",
    section: "Token Programs",
    tags: ["tokens", "mint"],
    difficulty: "foundation",
    prompt: "What does a token mint account represent?",
    choices: [
      "A ledger of all token-holder balances",
      "Global configuration + authorities + supply metadata for a token type",
      "A wallet’s token portfolio",
      "An RPC index of token transfers",
    ],
    answerIndex: 1,
    explanation:
      "Mints define the token type (decimals, supply, authorities). Individual balances live in token accounts.",
    deepDive:
      "This separation (mint vs token accounts) is why “one balance per wallet” is not implicit on Solana—ATAs make it conventional.",
  },
  {
    id: "Q047",
    section: "Token Programs",
    tags: ["tokens", "freeze"],
    difficulty: "expert",
    prompt: "What is the purpose of a freeze authority?",
    choices: [
      "To sign blockhashes",
      "To lock token accounts from transfers",
      "To change validator votes",
      "To disable CPI",
    ],
    answerIndex: 1,
    explanation: "A freeze authority can freeze token accounts to halt transfers for that mint.",
    deepDive: "Often used for compliance or emergency controls.",
  },
  {
    id: "Q048",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "v0"],
    difficulty: "foundation",
    prompt: "Why were versioned (v0) transactions introduced?",
    choices: [
      "To replace signatures",
      "To enable Address Lookup Tables and larger account lists",
      "To remove blockhashes",
      "To make programs upgradable",
    ],
    answerIndex: 1,
    explanation:
      "v0 transactions support ALTs, which compress account lists for large transactions.",
    deepDive: "This enables complex multi-program workflows.",
  },
  {
    id: "Q049",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "compression"],
    difficulty: "advanced",
    prompt: "How do ALTs reduce transaction size?",
    choices: [
      "By hashing instructions",
      "By storing addresses on-chain and referencing them by index",
      "By removing account metas",
      "By compressing signatures",
    ],
    answerIndex: 1,
    explanation:
      "ALTs store addresses on-chain so transactions can reference them by small indexes.",
    deepDive: "This reduces the byte cost of large account lists.",
  },
  {
    id: "Q050",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "authority"],
    difficulty: "advanced",
    prompt: "Who controls an ALT’s contents?",
    choices: [
      "Any program that references it",
      "Its authority (set at creation)",
      "The system program",
      "The fee payer",
    ],
    answerIndex: 1,
    explanation: "Each ALT has an authority that can extend, deactivate, or close it.",
    deepDive: "This prevents arbitrary tampering with lookup tables.",
  },
  {
    id: "Q051",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "use"],
    difficulty: "foundation",
    prompt: "Which transaction types can use ALTs?",
    choices: ["Legacy only", "v0 (versioned) only", "Both legacy and v0", "Only vote transactions"],
    answerIndex: 1,
    explanation: "ALTs are supported only in v0 (versioned) transactions.",
    deepDive: "Legacy transactions have fixed account list size limits.",
  },
  {
    id: "Q052",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "pitfall"],
    difficulty: "expert",
    prompt: "A common ALT pitfall is…",
    choices: [
      "You can’t use writable accounts",
      "You must include the ALT account itself in the tx message",
      "ALT addresses are mutable by anyone",
      "ALTs replace instruction data",
    ],
    answerIndex: 1,
    explanation:
      "The ALT account must be referenced in the transaction so the runtime can load it.",
    deepDive: "Missing the ALT account results in address resolution failures.",
  },
  {
    id: "Q053",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "slots"],
    difficulty: "foundation",
    prompt: "In Solana, a “slot” is best understood as…",
    choices: [
      "A finalized block",
      "A scheduled leader window in which a leader produces entries/blocks",
      "A single transaction",
      "A validator vote message",
    ],
    answerIndex: 1,
    explanation:
      "Slots are time windows assigned to leaders. Blocks/entries are produced during slots; finality is a separate concept.",
    deepDive:
      "This is why leaders can influence ordering within their slot: scheduling is explicit.",
  },
  {
    id: "Q054",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "ordering"],
    difficulty: "advanced",
    prompt: "Proof of History (PoH) is most usefully thought of as…",
    choices: [
      "A finality gadget",
      "A verifiable ordering/clock primitive used to sequence events efficiently",
      "A slashing system for dishonest validators",
      "A randomness beacon for leader selection",
    ],
    answerIndex: 1,
    explanation:
      "PoH provides a verifiable sequence that helps order events without requiring everyone to agree on timestamps.",
    deepDive:
      "PoH helps with ordering/verification speed; consensus/finality still comes from stake-weighted voting.",
  },
  {
    id: "Q055",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "finality"],
    difficulty: "advanced",
    prompt: "What is the difference between ‘confirmed’ and ‘finalized’?",
    choices: [
      "Confirmed is irreversible; finalized is reversible",
      "Finalized has stronger consensus weight and is very unlikely to revert",
      "They are identical",
      "Confirmed means all validators signed",
    ],
    answerIndex: 1,
    explanation:
      "Finalized has stronger BFT consensus weight and is extremely unlikely to revert compared to confirmed.",
    deepDive: "Use finalized for high-value actions; confirmed is often fine for UX.",
  },
  {
    id: "Q056",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "votes"],
    difficulty: "advanced",
    prompt: "What role do vote accounts play?",
    choices: [
      "They store token balances",
      "They cast votes on forks and earn rewards",
      "They store program data",
      "They track ALTs",
    ],
    answerIndex: 1,
    explanation:
      "Vote accounts are used by validators to vote on the fork choice and collect rewards.",
    deepDive: "Stake weight and voting drive consensus.",
  },
  {
    id: "Q057",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "stake"],
    difficulty: "foundation",
    prompt: "Consensus weight in Solana is primarily based on…",
    choices: ["Compute units", "Stake weight", "Number of transactions", "CPU cores"],
    answerIndex: 1,
    explanation: "Stake weight determines voting power and leader schedule priority.",
    deepDive: "This is standard for PoS systems.",
  },
  {
    id: "Q058",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "security"],
    difficulty: "expert",
    prompt: "PoH does NOT directly guarantee…",
    choices: [
      "Event ordering",
      "A cryptographic clock",
      "Whether a leader is honest about when they saw transactions",
      "Faster verification",
    ],
    answerIndex: 2,
    explanation:
      "PoH provides ordering and a clock, but it doesn’t prove when a leader actually received a transaction.",
    deepDive: "This is why MEV and leader control are still relevant.",
  },
  {
    id: "Q059",
    section: "Validator Pipeline & Networking",
    tags: ["tpu", "network"],
    difficulty: "foundation",
    prompt: "If your transaction never seems to reach a leader, which subsystem is most relevant?",
    choices: [
      "TPU (ingest/schedule path)",
      "TVU (replay/verification path)",
      "Rent sysvar",
      "BPF loader",
    ],
    answerIndex: 0,
    explanation:
      "TPU is the hot path for transaction ingestion and forwarding toward leaders for inclusion.",
    deepDive:
      "TVU is about replaying blocks you received; TPU is about getting your tx into the pipeline.",
  },
  {
    id: "Q060",
    section: "Validator Pipeline & Networking",
    tags: ["tvu", "network"],
    difficulty: "advanced",
    prompt: "The TVU (Transaction Validation Unit) primarily handles…",
    choices: [
      "Transaction ingestion",
      "Block verification and replay",
      "Fee estimation",
      "Account creation",
    ],
    answerIndex: 1,
    explanation: "The TVU verifies and replays blocks produced by leaders to update state.",
    deepDive: "This keeps validators in sync with the ledger.",
  },
  {
    id: "Q061",
    section: "Validator Pipeline & Networking",
    tags: ["quic", "qos"],
    difficulty: "advanced",
    prompt: "Why was QUIC adopted for transaction ingestion?",
    choices: [
      "It allows smart contracts",
      "It provides better flow control and resilience under load",
      "It removes signatures",
      "It speeds up PoH",
    ],
    answerIndex: 1,
    explanation: "QUIC improves flow control and robustness for packetized transaction ingest.",
    deepDive: "It helps reduce spam impact and improves stability.",
  },
  {
    id: "Q062",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "stake"],
    difficulty: "advanced",
    prompt: "Stake-weighted QoS means…",
    choices: [
      "All packets are equal",
      "Traffic from staked validators/RPCs gets priority",
      "Only validators can submit transactions",
      "Fees are ignored",
    ],
    answerIndex: 1,
    explanation: "Stake-weighted QoS prioritizes packets from staked validators or their peers.",
    deepDive: "This improves spam resistance during congestion.",
  },
  {
    id: "Q063",
    section: "Validator Pipeline & Networking",
    tags: ["gossip", "cluster"],
    difficulty: "foundation",
    prompt: "Gossip is primarily used to…",
    choices: [
      "Execute transactions",
      "Propagate cluster metadata (peers, votes, leader schedule info, etc.)",
      "Store account state snapshots",
      "Perform CPI routing",
    ],
    answerIndex: 1,
    explanation:
      "Gossip is the cluster’s “who’s here and what’s happening” propagation layer, not the execution engine.",
    deepDive:
      "It’s why nodes can discover each other and share state-of-the-network info without centralized coordination.",
  },
  {
    id: "Q064",
    section: "Validator Pipeline & Networking",
    tags: ["turbine", "shreds"],
    difficulty: "expert",
    prompt: "Turbine’s role is to…",
    choices: [
      "Sign transactions",
      "Efficiently broadcast blocks via shreds",
      "Compute fees",
      "Store snapshots",
    ],
    answerIndex: 1,
    explanation: "Turbine is Solana’s block propagation protocol using shreds.",
    deepDive: "It reduces bandwidth requirements compared to naive broadcast.",
  },
  {
    id: "Q065",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "foundation",
    prompt: "Commitment levels in RPC allow clients to…",
    choices: [
      "Choose token programs",
      "Select how finalized the queried data should be",
      "Set compute limits",
      "Bypass fees",
    ],
    answerIndex: 1,
    explanation: "Commitment levels control how finalized/confirmed the data should be.",
    deepDive: "Clients can trade speed for finality.",
  },
  {
    id: "Q066",
    section: "RPC & Client Behavior",
    tags: ["rpc", "simulation"],
    difficulty: "advanced",
    prompt: "Why simulate transactions before sending?",
    choices: [
      "To bypass fees",
      "To detect errors and estimate logs/compute",
      "To finalize immediately",
      "To change the blockhash",
    ],
    answerIndex: 1,
    explanation: "Simulation reveals errors, logs, and compute usage without committing state.",
    deepDive: "It’s essential for debugging and fee tuning.",
  },
  {
    id: "Q067",
    section: "RPC & Client Behavior",
    tags: ["rpc", "websocket"],
    difficulty: "advanced",
    prompt: "When should you prefer WebSocket subscriptions over polling?",
    choices: [
      "Never",
      "When you need near-real-time account updates",
      "Only for token balances",
      "Only for vote accounts",
    ],
    answerIndex: 1,
    explanation: "WebSocket subscriptions deliver near-real-time updates without heavy polling.",
    deepDive: "This reduces RPC load and latency for live UX.",
  },
  {
    id: "Q068",
    section: "RPC & Client Behavior",
    tags: ["rpc", "retries"],
    difficulty: "advanced",
    prompt: "A robust client should retry on…",
    choices: [
      "All errors equally",
      "Transient errors like blockhash not found or node timeouts",
      "Only signature verification failures",
      "Only program errors",
    ],
    answerIndex: 1,
    explanation:
      "Transient network errors or blockhash expiry are common; retries with a fresh blockhash help.",
    deepDive: "Program errors should usually not be retried without changes.",
  },
  {
    id: "Q069",
    section: "RPC & Client Behavior",
    tags: ["rpc", "finality"],
    difficulty: "expert",
    prompt: "Why might a transaction be ‘confirmed’ but later not finalized?",
    choices: [
      "Confirmed is stronger than finalized",
      "Forks can still occur before finality thresholds are reached",
      "Validators ignore confirmed blocks",
      "Only on devnet",
    ],
    answerIndex: 1,
    explanation:
      "Confirmed data can still be on a fork that doesn’t reach finality; finalized is stronger.",
    deepDive: "This is rare but important for high-value operations.",
  },
  {
    id: "Q070",
    section: "RPC & Client Behavior",
    tags: ["rpc", "data"],
    difficulty: "foundation",
    prompt: "Account data fetched from RPC is…",
    choices: [
      "Always the final state",
      "Dependent on commitment level",
      "Encrypted",
      "Not affected by forks",
    ],
    answerIndex: 1,
    explanation:
      "RPC responses depend on commitment levels and can be affected by forks pre-finality.",
    deepDive: "Use higher commitment for critical reads.",
  },
  {
    id: "Q071",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "feature-gates"],
    difficulty: "advanced",
    prompt: "In Solana, when is a protocol change actually live?",
    choices: [
      "When a SIMD is merged",
      "When the validator release is published",
      "When the feature gate is activated on-chain",
      "When the docs update",
    ],
    answerIndex: 2,
    explanation:
      "The real switch is feature-gate activation; releases can ship code before activation.",
    deepDive: "This enables staged rollouts across clusters.",
  },
  {
    id: "Q072",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "process"],
    difficulty: "foundation",
    prompt: "What makes SIMDs useful in the Solana ecosystem?",
    choices: [
      "They are code that runs on validators to activate features",
      "They are proposal documents that track design rationale and lifecycle (review → accepted → implemented → activated)",
      "They are mandatory for program upgrades",
      "They are a token standard for governance",
    ],
    answerIndex: 1,
    explanation:
      "SIMDs are the design/process artifact; activation is handled separately via feature gates.",
    deepDive: "This teaches “paper accepted” ≠ “feature live,” which is core in Solana operations.",
  },
  {
    id: "Q073",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "activation"],
    difficulty: "advanced",
    prompt: "Why use feature gates?",
    choices: [
      "To hide code from validators",
      "To activate changes safely and sequentially",
      "To skip testing",
      "To replace governance",
    ],
    answerIndex: 1,
    explanation: "Feature gates allow controlled, staged activation of protocol changes.",
    deepDive: "They decouple code shipping from on-chain activation.",
  },
  {
    id: "Q074",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["release", "validator"],
    difficulty: "advanced",
    prompt: "Why might validators upgrade before a feature is active?",
    choices: [
      "They are forced to",
      "The feature is behind a gate and can be activated later",
      "Because it saves fees",
      "To change consensus rules immediately",
    ],
    answerIndex: 1,
    explanation:
      "Validators often upgrade to a version that includes gated features that activate later.",
    deepDive: "This is standard staged rollout practice.",
  },
  {
    id: "Q075",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["forks", "activation"],
    difficulty: "expert",
    prompt: "What’s a risk if validators activate a feature without network readiness?",
    choices: [
      "Nothing; activation is always safe",
      "Potential forks or instability if versions diverge",
      "Fees drop to zero",
      "Transactions become free",
    ],
    answerIndex: 1,
    explanation: "Activation before broad upgrade can cause divergence or instability.",
    deepDive: "This is why activation schedules are conservative.",
  },
  {
    id: "Q076",
    section: "Security & Pitfalls",
    tags: ["security", "signers"],
    difficulty: "foundation",
    prompt: "What is a common security pitfall in Solana programs?",
    choices: [
      "Checking account ownership and signer flags",
      "Failing to check account ownership/signers",
      "Using PDAs",
      "Using sysvars",
    ],
    answerIndex: 1,
    explanation: "Not validating ownership/signers can allow unauthorized mutations.",
    deepDive: "Always assert owners, signers, and expected addresses.",
  },
  {
    id: "Q077",
    section: "Security & Pitfalls",
    tags: ["security", "replay"],
    difficulty: "advanced",
    prompt: "Why include nonce or unique seeds in PDA derivations?",
    choices: [
      "To avoid rent",
      "To avoid address collisions",
      "To increase compute",
      "To enable CPI",
    ],
    answerIndex: 1,
    explanation: "Unique seeds ensure distinct PDAs per user/position and avoid collisions.",
    deepDive: "Deterministic uniqueness reduces state overlap.",
  },
  {
    id: "Q078",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "advanced",
    prompt: "A CPI pitfall is…",
    choices: [
      "Not passing required accounts",
      "Passing accounts with more privilege than allowed",
      "Assuming CPI can create new signers",
      "All of the above",
    ],
    answerIndex: 3,
    explanation:
      "CPI requires precise accounts and privilege rules; mistakes lead to failure or security issues.",
    deepDive: "CPI cannot magically elevate privileges.",
  },
  {
    id: "Q079",
    section: "Security & Pitfalls",
    tags: ["security", "logging"],
    difficulty: "foundation",
    prompt: "Why shouldn’t you treat logs as authoritative state?",
    choices: [
      "Logs are always encrypted",
      "Logs are hints, not canonical on-chain state",
      "Logs are mandatory for state changes",
      "Logs are only on devnet",
    ],
    answerIndex: 1,
    explanation: "Logs are for debugging/UX; canonical state lives in account data.",
    deepDive: "Build on account data, not log parsing.",
  },
  {
    id: "Q080",
    section: "Security & Pitfalls",
    tags: ["security", "reentrancy"],
    difficulty: "expert",
    prompt: "Solana programs are still vulnerable to reentrancy-like issues when…",
    choices: [
      "They call CPI to untrusted programs without state checks",
      "They use PDAs",
      "They use sysvars",
      "They are written in Rust",
    ],
    answerIndex: 0,
    explanation:
      "CPI to untrusted programs can introduce reentrancy-like control flow if state is not managed carefully or program IDs aren’t validated.",
    deepDive: "Use checks-effects-interactions and validate expected program IDs.",
  },
  {
    id: "Q081",
    section: "Transactions & Instructions",
    tags: ["instructions", "order"],
    difficulty: "advanced",
    prompt: "Why does instruction order in a transaction matter?",
    choices: [
      "It never matters",
      "Later instructions can depend on state changes from earlier ones",
      "It only matters for sysvars",
      "It only matters for fees",
    ],
    answerIndex: 1,
    explanation:
      "Instructions execute sequentially; later instructions see state changes from earlier ones.",
    deepDive: "This enables complex atomic workflows.",
  },
  {
    id: "Q082",
    section: "Transactions & Instructions",
    tags: ["instructions", "accounts"],
    difficulty: "advanced",
    prompt: "If two instructions in one tx write the same account…",
    choices: [
      "It is not allowed",
      "It is allowed; they execute in order within the tx",
      "The account becomes read-only",
      "It must be a PDA",
    ],
    answerIndex: 1,
    explanation: "Within a transaction, multiple writes are allowed; the tx is atomic and ordered.",
    deepDive: "Parallelism is across transactions, not within a single one.",
  },
  {
    id: "Q083",
    section: "Transactions & Instructions",
    tags: ["instructions", "limits"],
    difficulty: "expert",
    prompt: "Why can large multi-instruction transactions still fail even with ALTs?",
    choices: [
      "ALTs increase compute",
      "Compute budget and account limits still apply",
      "ALTs only work on devnet",
      "They are rejected by wallets",
    ],
    answerIndex: 1,
    explanation: "ALTs solve address size, not compute or runtime limits.",
    deepDive: "Compute budget, CPI depth, and account limits still constrain complexity.",
  },
  {
    id: "Q084",
    section: "PDAs & Signers",
    tags: ["pda", "seeds"],
    difficulty: "advanced",
    prompt: "Which seed strategy is safest for a PDA?",
    choices: [
      "A single static seed",
      "User pubkey + program-specific constant",
      "Recent blockhash",
      "Validator identity",
    ],
    answerIndex: 1,
    explanation: "Combining user pubkey with a constant ensures stable, unique addresses per user.",
    deepDive: "Avoid ephemeral seeds that change unpredictably.",
  },
  {
    id: "Q085",
    section: "PDAs & Signers",
    tags: ["pda", "init"],
    difficulty: "advanced",
    prompt: "When initializing a PDA account, a typical pattern is…",
    choices: [
      "Program allocates and assigns via system program CPI",
      "Program directly writes to account data without create",
      "User signs for the PDA",
      "PDA signs for itself",
    ],
    answerIndex: 0,
    explanation: "Programs create PDA accounts via CPI to the system program, using invoke_signed.",
    deepDive: "This ensures proper lamports and ownership assignment.",
  },
  {
    id: "Q086",
    section: "Programs & CPI",
    tags: ["cpi", "accounts"],
    difficulty: "foundation",
    prompt: "If a program needs an account during CPI, it must…",
    choices: [
      "Read it from RPC",
      "Receive it from the caller as an account input",
      "Derive it internally without passing",
      "Use sysvars",
    ],
    answerIndex: 1,
    explanation:
      "Programs can only access accounts passed into the instruction (and in CPI, passed along).",
    deepDive: "No implicit access to global state.",
  },
  {
    id: "Q087",
    section: "Programs & CPI",
    tags: ["cpi", "signer"],
    difficulty: "advanced",
    prompt: "How can a program authorize a CPI that requires a signer?",
    choices: [
      "By setting the account to writable",
      "By using invoke_signed with PDA seeds",
      "By skipping signature checks",
      "By paying extra fees",
    ],
    answerIndex: 1,
    explanation: "invoke_signed provides PDA-based signing authority for CPI signers.",
    deepDive: "This is the core of PDA authority delegation.",
  },
  {
    id: "Q088",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why is ‘account list’ a scalability bottleneck for some apps?",
    choices: [
      "Because accounts are too small",
      "Because transaction size limits the number of accounts",
      "Because accounts must be encrypted",
      "Because account lists are random",
    ],
    answerIndex: 1,
    explanation: "Each account meta costs bytes; large workflows hit size limits without ALTs.",
    deepDive: "ALTs help, but compute and CPI depth still constrain complexity.",
  },
  {
    id: "Q089",
    section: "Runtime & Parallelism",
    tags: ["runtime", "determinism"],
    difficulty: "advanced",
    prompt: "Why must program execution be deterministic?",
    choices: [
      "To reduce fees",
      "So all validators reach the same state",
      "To allow PoH",
      "To improve UX",
    ],
    answerIndex: 1,
    explanation: "Determinism ensures all validators compute identical state transitions.",
    deepDive: "Non-determinism would split consensus.",
  },
  {
    id: "Q090",
    section: "Fees & Compute Budget",
    tags: ["compute", "budget"],
    difficulty: "expert",
    prompt: "Why might requesting too many compute units be counterproductive?",
    choices: [
      "It lowers your priority fee",
      "It increases cost and may reduce inclusion if too expensive",
      "It increases account limits",
      "It disables CPI",
    ],
    answerIndex: 1,
    explanation:
      "Requesting a high CU limit raises max fee (when unit price > 0); under congestion, it can price you out and reduce inclusion likelihood.",
    deepDive: "Tune CU limit and unit price based on workload.",
  },
  {
    id: "Q091",
    section: "Token Programs",
    tags: ["tokens", "extensions"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions require extra account space?",
    choices: [
      "Because extension metadata is stored in the account",
      "Because extensions increase compute",
      "Because extensions add new PDAs",
      "Because extensions require sysvars",
    ],
    answerIndex: 0,
    explanation:
      "Extensions store additional data in the token account/mint, requiring extra space.",
    deepDive: "Account size must be allocated to fit extension state.",
  },
  {
    id: "Q092",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "advanced",
    prompt: "Why can a token transfer fail even if the sender has enough balance?",
    choices: [
      "Because token accounts are read-only",
      "Because the token program ID or authority is wrong",
      "Because of PoH",
      "Because CPI is not allowed",
    ],
    answerIndex: 1,
    explanation:
      "Common failures include wrong token program ID, missing signer, or frozen accounts.",
    deepDive: "Token transfers are authority-checked, not just balance-based.",
  },
  {
    id: "Q093",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "lifecycle"],
    difficulty: "advanced",
    prompt: "What happens when an ALT is deactivated?",
    choices: [
      "All transactions using it revert",
      "It can’t be extended and will expire after a cooldown",
      "It becomes read-only forever",
      "It loses all addresses immediately",
    ],
    answerIndex: 1,
    explanation: "Deactivation starts a cooldown period; after that it can be closed.",
    deepDive: "This prevents immediate removal that could break pending transactions.",
  },
  {
    id: "Q094",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "design"],
    difficulty: "expert",
    prompt: "Why do aggregators maintain multiple ALTs instead of one giant table?",
    choices: [
      "ALTs cannot exceed 5 addresses",
      "Different routes require different account sets; smaller ALTs reduce stale entries",
      "Because ALTs cost too many fees",
      "Because ALTs are validator-only",
    ],
    answerIndex: 1,
    explanation:
      "Route-specific ALTs keep tables focused and avoid unused/stale entries (and ALTs are capped in size).",
    deepDive: "This improves reliability and reduces maintenance overhead.",
  },
  {
    id: "Q095",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "forks"],
    difficulty: "expert",
    prompt: "What causes a fork in Solana?",
    choices: [
      "A blockhash change",
      "Two leaders produce competing blocks for the same slot range",
      "A missing PDA",
      "RPC timeout",
    ],
    answerIndex: 1,
    explanation: "Forks occur when different validators see different valid blocks or sequences.",
    deepDive: "Consensus resolves forks based on stake-weighted votes.",
  },
  {
    id: "Q096",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "leader"],
    difficulty: "advanced",
    prompt: "How is the leader schedule determined?",
    choices: [
      "By random selection per transaction",
      "By stake-weighted deterministic schedule",
      "By fee payer",
      "By sysvar",
    ],
    answerIndex: 1,
    explanation: "Leader schedule is deterministic and stake-weighted over epochs.",
    deepDive: "This makes leader assignment predictable but weighted by stake.",
  },
  {
    id: "Q097",
    section: "Validator Pipeline & Networking",
    tags: ["shreds", "data"],
    difficulty: "advanced",
    prompt: "Why are blocks split into shreds?",
    choices: [
      "To hide data",
      "To enable efficient propagation and repair",
      "To reduce compute",
      "To simplify CPI",
    ],
    answerIndex: 1,
    explanation: "Shreds allow parallel distribution and repair of block data via Turbine.",
    deepDive: "It’s a key scalability mechanism.",
  },
  {
    id: "Q098",
    section: "Validator Pipeline & Networking",
    tags: ["repair", "turbine"],
    difficulty: "expert",
    prompt: "What is the purpose of repair in Solana’s networking?",
    choices: [
      "To allocate compute units",
      "To recover missing shreds and maintain ledger continuity",
      "To sign blocks",
      "To change leader schedule",
    ],
    answerIndex: 1,
    explanation:
      "Repair protocols fetch missing shreds to complete blocks and maintain ledger consistency.",
    deepDive: "This improves resilience under packet loss.",
  },
  {
    id: "Q099",
    section: "RPC & Client Behavior",
    tags: ["rpc", "indexing"],
    difficulty: "advanced",
    prompt: "Why do many production apps run their own indexers?",
    choices: [
      "Because RPC never works",
      "To build fast, app-specific queries beyond basic RPC",
      "To avoid writing programs",
      "To bypass fees",
    ],
    answerIndex: 1,
    explanation: "RPC is general-purpose; indexers provide fast, domain-specific queries.",
    deepDive: "This is similar to subgraphs or custom indexers on other chains.",
  },
  {
    id: "Q100",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "expert",
    prompt: "Why might ‘processed’ commitment be dangerous for user balances?",
    choices: [
      "It requires sysvars",
      "It can reflect forks that are not confirmed/finalized",
      "It is slower",
      "It costs more",
    ],
    answerIndex: 1,
    explanation: "Processed data can be on forks that never finalize; balances may revert.",
    deepDive: "Use confirmed/finalized for critical reads.",
  },
  {
    id: "Q101",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "clusters"],
    difficulty: "advanced",
    prompt: "Why are features activated on testnet before mainnet?",
    choices: [
      "To increase fees",
      "To validate behavior under realistic conditions",
      "To reduce compute",
      "To bypass governance",
    ],
    answerIndex: 1,
    explanation:
      "Staged activation reduces risk by validating changes under real load before mainnet.",
    deepDive: "This is standard in Solana’s rollout model.",
  },
  {
    id: "Q102",
    section: "Security & Pitfalls",
    tags: ["security", "pda"],
    difficulty: "expert",
    prompt: "Which statement about PDA “collisions” is most accurate?",
    choices: [
      "A cryptographic hash collision is feasible with enough brute force",
      "Cryptographic collisions are infeasible, but ambiguous seed schemas can still cause unintended address overlap",
      "The bump guarantees uniqueness across all seed schemas",
      "The runtime inserts delimiters between seeds to prevent any overlap",
    ],
    answerIndex: 1,
    explanation:
      "A true cryptographic collision is infeasible, but developers can create practical “collisions” via ambiguous seed schemas (e.g., variable-length seeds without clear boundaries).",
    deepDive:
      "Audit rule: use explicit namespaces and unambiguous seed boundaries (fixed-size components or length-prefixing) to prevent cross-type overlap.",
  },
  {
    id: "Q103",
    section: "Security & Pitfalls",
    tags: ["security", "accounts"],
    difficulty: "advanced",
    prompt: "Why should you verify account addresses explicitly?",
    choices: [
      "To reduce compute",
      "To prevent account substitution attacks",
      "To increase parallelism",
      "To avoid using PDAs",
    ],
    answerIndex: 1,
    explanation: "Attackers can pass arbitrary accounts; programs must enforce expected addresses.",
    deepDive: "Always check PDA derivations and owners.",
  },
  {
    id: "Q104",
    section: "Security & Pitfalls",
    tags: ["security", "init"],
    difficulty: "advanced",
    prompt: "What is a common initialization bug?",
    choices: [
      "Failing to set account data",
      "Re-initializing an already initialized account",
      "Using sysvars",
      "Using PDAs",
    ],
    answerIndex: 1,
    explanation: "Programs should guard against re-initialization to prevent state resets.",
    deepDive: "A discriminator or ‘is_initialized’ flag is typical.",
  },
  {
    id: "Q105",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "expert",
    prompt: "What does ‘signer privilege escalation’ mean in CPI context?",
    choices: [
      "Giving signer rights to an account that wasn’t a signer in the outer tx",
      "Using a PDA as signer",
      "Using system program",
      "Passing too many accounts",
    ],
    answerIndex: 0,
    explanation:
      "Signers can’t be escalated in CPI unless the program proves PDA authority via invoke_signed.",
    deepDive: "This protects users from unauthorized signing.",
  },
  {
    id: "Q106",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "commitment"],
    difficulty: "advanced",
    prompt: "Why might you wait for finalized status when bridging or settling?",
    choices: [
      "Because finalized can still revert",
      "Because finality reduces the risk of fork reorgs",
      "Because it increases fees",
      "Because it disables CPI",
    ],
    answerIndex: 1,
    explanation: "Finalized has stronger finality and much lower reorg risk.",
    deepDive: "Critical financial operations should wait for finalized.",
  },
  {
    id: "Q107",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "verification"],
    difficulty: "expert",
    prompt: "Why can PoH be verified faster than recomputed?",
    choices: [
      "Because validators skip hashes",
      "Because it’s a sequential hash chain with checkpoints/entries",
      "Because it uses GPUs only",
      "Because it’s randomized",
    ],
    answerIndex: 1,
    explanation:
      "PoH produces a sequential hash chain/clock; verifying the chained entries is efficient compared to reproducing the leader’s full production pipeline.",
    deepDive: "This enables efficient time-order verification.",
  },
  {
    id: "Q108",
    section: "Validator Pipeline & Networking",
    tags: ["leader", "mev"],
    difficulty: "expert",
    prompt: "Why can leaders influence transaction ordering?",
    choices: [
      "They can rewrite signatures",
      "They choose transaction ordering within their slot",
      "They control the system program",
      "They own all PDAs",
    ],
    answerIndex: 1,
    explanation: "Leaders decide ordering of transactions they include in their slots.",
    deepDive: "This is a source of MEV-like behavior.",
  },
  {
    id: "Q109",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "spam"],
    difficulty: "advanced",
    prompt: "How does stake-weighted QoS help under spam?",
    choices: [
      "It increases compute units",
      "It prioritizes packets from staked sources",
      "It removes fees",
      "It disables CPI",
    ],
    answerIndex: 1,
    explanation:
      "Stake-weighted QoS prefers traffic from staked validators/peers, reducing spam impact.",
    deepDive: "It’s a network-level defense.",
  },
  {
    id: "Q110",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why can two transactions touching the same writable account not run in parallel?",
    choices: [
      "Because of fee rules",
      "Because it would cause write-write conflicts",
      "Because of PoH",
      "Because of stake-weighted QoS",
    ],
    answerIndex: 1,
    explanation: "Write locks are exclusive; concurrent writes could break deterministic state.",
    deepDive: "Parallelism depends on non-overlapping write sets.",
  },
  {
    id: "Q111",
    section: "Token Programs",
    tags: ["tokens", "2022"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions complicate CPI?",
    choices: [
      "Extensions add extra required accounts/constraints",
      "Extensions remove signatures",
      "Extensions disable PDAs",
      "Extensions prevent ATAs",
    ],
    answerIndex: 0,
    explanation:
      "Extensions can require extra accounts or checks (e.g., transfer hooks), affecting CPI flows.",
    deepDive: "Clients and programs must include the right extra accounts.",
  },
  {
    id: "Q112",
    section: "Fees & Compute Budget",
    tags: ["fees", "market"],
    difficulty: "advanced",
    prompt: "What’s the best way to improve landing rate during congestion?",
    choices: [
      "Increase transaction size",
      "Add priority fee (unit price) and ensure compute budget is accurate",
      "Remove signatures",
      "Use sysvars",
    ],
    answerIndex: 1,
    explanation:
      "A reasonable priority fee and accurate compute budget improve inclusion likelihood.",
    deepDive: "Over-requesting compute can backfire by raising cost.",
  },
  {
    id: "Q113",
    section: "Versioned Transactions & ALTs",
    tags: ["v0", "wallets"],
    difficulty: "advanced",
    prompt: "Why might some wallets fail to sign a v0 transaction?",
    choices: [
      "They don’t support versioned txs",
      "They require PDAs",
      "They only support Token-2022",
      "They disallow sysvars",
    ],
    answerIndex: 0,
    explanation: "Older wallets might not support v0 transaction parsing/signing.",
    deepDive: "Most modern wallets now support v0, but compatibility matters.",
  },
  {
    id: "Q114",
    section: "Transactions & Instructions",
    tags: ["instructions", "data"],
    difficulty: "foundation",
    prompt: "Instruction data is…",
    choices: [
      "A fixed schema enforced by the runtime",
      "Arbitrary bytes interpreted by the program",
      "Always JSON",
      "Always an opcode",
    ],
    answerIndex: 1,
    explanation:
      "The runtime treats instruction data as opaque bytes; the program defines the schema.",
    deepDive: "This allows custom encoding strategies.",
  },
  {
    id: "Q115",
    section: "Programs & CPI",
    tags: ["programs", "logs"],
    difficulty: "foundation",
    prompt: "Program logs are best used for…",
    choices: ["Canonical state", "Debugging and UX hints", "Consensus voting", "Fee collection"],
    answerIndex: 1,
    explanation: "Logs help debugging and UX but are not canonical state.",
    deepDive: "State lives in accounts.",
  },
  {
    id: "Q116",
    section: "Programs & CPI",
    tags: ["programs", "compute"],
    difficulty: "advanced",
    prompt: "Why can a single extra CPI break an otherwise working tx?",
    choices: [
      "It changes the blockhash",
      "It increases compute and account requirements",
      "It disables PDAs",
      "It makes the tx invalid",
    ],
    answerIndex: 1,
    explanation: "CPI adds compute and often requires extra accounts; that can exceed limits.",
    deepDive: "Always budget compute and accounts for CPI chains.",
  },
  {
    id: "Q117",
    section: "Security & Pitfalls",
    tags: ["security", "account-substitution"],
    difficulty: "advanced",
    prompt: "Account substitution attacks occur when…",
    choices: [
      "Programs don’t verify expected addresses/owners",
      "Accounts are read-only",
      "Using sysvars",
      "Using PDAs",
    ],
    answerIndex: 0,
    explanation: "If programs accept arbitrary accounts, attackers can substitute malicious ones.",
    deepDive: "Always validate addresses, owners, and derivations.",
  },
  {
    id: "Q118",
    section: "Security & Pitfalls",
    tags: ["security", "rent"],
    difficulty: "advanced",
    prompt: "Why should you check account data length when deserializing?",
    choices: [
      "To reduce fees",
      "To avoid panics and ensure correct layout",
      "To increase compute",
      "To bypass ownership",
    ],
    answerIndex: 1,
    explanation: "Unexpected data length can cause deserialization errors or security issues.",
    deepDive: "Length checks prevent malformed data attacks.",
  },
  {
    id: "Q119",
    section: "RPC & Client Behavior",
    tags: ["rpc", "confirmations"],
    difficulty: "advanced",
    prompt: "Why should you re-fetch account state after a confirmed transaction?",
    choices: [
      "To update the recent blockhash",
      "To verify the actual on-chain state and handle forks",
      "To reduce fees",
      "To avoid CPI",
    ],
    answerIndex: 1,
    explanation: "Confirmation is not finality; re-fetch ensures you see the canonical state.",
    deepDive: "This is especially important for critical balances.",
  },
  {
    id: "Q120",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "status"],
    difficulty: "advanced",
    prompt: "Which SIMD status most closely implies ‘live on mainnet’?",
    choices: ["Implemented", "Activated", "Accepted", "Review"],
    answerIndex: 1,
    explanation: "Activated indicates the feature gate has been turned on and is live.",
    deepDive: "Implemented only means the code exists in a release.",
  },
  {
    id: "Q121",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "pda", "security", "seeds"],
    difficulty: "advanced",
    prompt:
      'You have two PDA account types in the same program: Product uses seeds = [b"product", product_name.as_ref()], and Bid uses seeds = [product_name.as_ref(), user.key().as_ref()]. What’s the most realistic failure mode if you don’t carefully namespace/structure seeds?',
    choices: [
      "Nothing: different seed arrays always produce different PDAs",
      "An attacker can craft inputs that collide across types, blocking creation or confusing initialization flows",
      "An attacker can derive the PDA private key and sign",
      "The runtime inserts delimiters between seeds, so collisions are impossible",
    ],
    answerIndex: 1,
    explanation:
      "Seeds are processed as bytes, and variable-length parts can create ambiguous boundaries across different seed arrays. The invariant is: PDA uniqueness is only as strong as your seed schema. Use clear namespaces and unambiguous boundaries (fixed-size components or explicit length prefixes) so different account types cannot collide.",
    deepDive:
      "Seed hygiene checklist: unique static prefix per account type, avoid raw strings without length separation, prefer fixed-size components (pubkeys, hashes), and keep a stable namespace/version in the seed set.",
  },
  {
    id: "Q122",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "pda", "design", "security"],
    difficulty: "advanced",
    prompt: "Which seed design best prevents unintended collisions between different PDA types?",
    choices: [
      "Include unique static prefixes per PDA type and length-delimit any variable-length parts",
      "Use only user-controlled strings because they’re “unique enough”",
      "Reuse the same prefix everywhere for consistency",
      "Rely on bump alone for uniqueness",
    ],
    answerIndex: 0,
    explanation:
      "The invariant is that PDAs are only distinct if your seed schema makes them distinct. Unique prefixes + unambiguous boundaries prevent cross-type collisions even when user input is adversarial.",
    deepDive:
      'Practical schema: [b"type", version, fixed-size ids...] then length-delimited user strings if absolutely needed.',
  },
  {
    id: "Q123",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "remaining_accounts", "security"],
    difficulty: "advanced",
    prompt:
      "Your instruction iterates over ctx.remaining_accounts to distribute rewards. What must you assume about these accounts by default?",
    choices: [
      "Anchor applied the same constraints as in the Accounts struct",
      "They’re trusted because they were provided by the client SDK",
      "They have none of Anchor’s protections; you must validate owner, type, address/PDA, and initialization yourself",
      "They cannot be writable, so no harm is possible",
    ],
    answerIndex: 2,
    explanation:
      "Treat remaining accounts as raw, untrusted AccountInfo. The invariant is: Anchor only validates what you declared in the Accounts struct; everything else needs explicit checks.",
    deepDive:
      "Validation checklist: expected owner/program, discriminator/type, exact address or PDA derivation, initialized/liveness, and program/mint IDs for token flows.",
  },
  {
    id: "Q124",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "remaining_accounts", "tokens", "security"],
    difficulty: "advanced",
    prompt:
      "You accept a dynamic list of token accounts in remaining_accounts and transfer tokens to each. Which check would most directly prevent account-substitution theft?",
    choices: [
      "Verify each token account’s mint and that its owner matches the intended recipient from validated state, not user input",
      "Mark the list accounts as read-only",
      "Increase compute budget",
      "Use confirmed commitment instead of finalized",
    ],
    answerIndex: 0,
    explanation:
      "The invariant is: payouts must be bound to verified recipients, not to whatever accounts the caller supplies. Validate the token account’s owner/mint against trusted state and derive expected addresses when possible.",
    deepDive:
      "Design pattern: store recipient pubkeys in program state, derive ATAs from those pubkeys + mint, and verify the provided accounts match those ATAs.",
  },
  {
    id: "Q125",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "security", "program-id"],
    difficulty: "advanced",
    prompt:
      "Your Anchor instruction takes a lending_program: AccountInfo and CPI-calls it, forwarding the caller (Signer) and system_program. What’s the highest-risk assumption?",
    choices: [
      "CPI cannot escalate privileges, so this is safe",
      "If it compiles, the program is trusted",
      "If lending_program isn’t pinned, the caller can swap in a malicious program that uses the forwarded signer",
      "Only PDAs can be abused in CPI",
    ],
    answerIndex: 2,
    explanation:
      "This is a confused-deputy risk: signers remain signers during CPI, so an untrusted program can use the forwarded authority for unintended actions. The invariant is: never forward signer authority to an unverified program ID.",
    deepDive:
      "Mitigations: pin program IDs, avoid dynamic CPI targets, and minimize which signers/writable accounts you forward.",
  },
  {
    id: "Q126",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "invoke_signed", "pda", "security"],
    difficulty: "advanced",
    prompt:
      "Your program uses invoke_signed to act with a PDA authority, and the CPI target program is user-provided. Why is this especially dangerous?",
    choices: [
      "invoke_signed makes the PDA’s private key visible",
      "You are delegating PDA authority to an attacker-controlled program if the target isn’t trusted",
      "PDAs can only sign once per slot",
      "The system program rejects PDAs",
    ],
    answerIndex: 1,
    explanation:
      "invoke_signed effectively loans your PDA authority to the callee. If the target is untrusted, you’ve handed it the ability to act as your PDA within the accounts you pass.",
    deepDive:
      "Audit rule: any invoke_signed CPI with user-controlled program IDs is a red flag. Pin the target and restrict what the PDA is allowed to do.",
  },
  {
    id: "Q127",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "reload", "security"],
    difficulty: "advanced",
    prompt:
      "You CPI to token::mint_to, then immediately read ctx.accounts.mint.supply to enforce a limit. What’s the risk?",
    choices: [
      "None; Anchor account structs always reflect CPI side effects",
      "You’re reading stale deserialized data unless you reload, so the limit check can be bypassed",
      "The supply becomes finalized-only after CPI",
      "The CPI invalidates the transaction signature",
    ],
    answerIndex: 1,
    explanation:
      "Anchor caches deserialized data in Account<'info, T>. CPI mutates the underlying AccountInfo bytes, not the cached struct. The invariant: after any CPI that may mutate an account you later read, reload before using its fields.",
    deepDive:
      "Rule of thumb: CPI → read fields from the same account struct → call reload() first.",
  },
  {
    id: "Q128",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "reload", "audit"],
    difficulty: "advanced",
    prompt: "In code review, where should you look for missing reload() calls?",
    choices: [
      "Anywhere a CPI is followed by reads of fields from Account<'info, T> that the CPI could have changed",
      "Only in instructions that call the system program",
      "Only when using ALTs",
      "Only for read-only accounts",
    ],
    answerIndex: 0,
    explanation:
      "The auditing heuristic is simple: if a CPI can mutate an account and the code reads from its cached struct afterward, a reload is required to re-deserialize from bytes.",
    deepDive:
      "Search pattern: `CPI` then `account.field` without an intervening `account.reload()`.",
  },
];
