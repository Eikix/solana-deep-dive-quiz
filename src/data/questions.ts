import type { Question } from "@/types/quiz";

export const questions: Question[] = [
  {
    id: "Q001",
    section: "Accounts & Ownership",
    tags: ["accounts", "ownership"],
    difficulty: "foundation",
    prompt: "What does it mean for a program to “own” an account?",
    choices: [
      "The program’s owner field implies it can sign for the account",
      "The program may debit lamports without a system-program transfer",
      "The program has write authority over the account’s data and size",
      "The account is restricted to that program’s instructions, not CPI",
    ],
    answerIndex: 2,
    explanation:
      "Ownership is about write authority over account data (and typically resizing). It does not grant signing power, and it doesn’t imply the account can’t be used in CPI.",
    deepDive:
      "Think of owner as “who interprets and may mutate this data.” Signing is a transaction-level proof, and lamport movement is constrained by runtime rules and explicit authorization patterns.",
  },
  {
    id: "Q002",
    section: "Accounts & Ownership",
    tags: ["accounts", "lamports"],
    difficulty: "foundation",
    prompt: "Which statement about native lamports is most accurate?",
    choices: [
      "Any program can move lamports if the account is marked writable",
      "Lamport balance is just another data field controlled by the owner program",
      "Lamport balance changes are constrained by runtime invariants; user transfers require proper authorization, typically via the system program",
      "Lamport balances are derived from sysvars and not stored on accounts",
    ],
    answerIndex: 2,
    explanation:
      "Lamports are part of account state, but the runtime enforces invariants and authorization. Writable alone doesn’t let arbitrary debits happen; typical wallet transfers follow system-program rules (signer/authority).",
    deepDive:
      "A good mental model: who may write data (owner), who authorizes actions (signers), and what state transitions are allowed (runtime + program rules) are separate axes.",
  },
  {
    id: "Q003",
    section: "Accounts & Ownership",
    tags: ["accounts", "rent"],
    difficulty: "advanced",
    prompt: "Why do many programs require accounts to be rent-exempt?",
    choices: [
      "To make future reallocations free after the first allocation",
      "To ensure accounts meet the minimum balance for durable state",
      "To skip write locks on long-lived state accounts",
      "To bypass owner checks during CPI",
    ],
    answerIndex: 1,
    explanation:
      "Programs often assume state must persist long-term. Rent-exempt funding is the common “durable state” convention and avoids rent-related edge cases or future policy changes.",
    deepDive:
      "Even if rent collection isn’t something most devs feel day-to-day, funding state accounts adequately remains best practice for long-lived protocol state.",
  },
  {
    id: "Q004",
    section: "Accounts & Ownership",
    tags: ["accounts", "data"],
    difficulty: "advanced",
    prompt: "Which account data change is always permitted?",
    choices: [
      "Any program that receives a writable AccountInfo may mutate its data",
      "The owning program may mutate or resize the account data",
      "Any signer in the transaction may mutate that account’s data",
      "A program may resize a read-only account if it is also a signer",
    ],
    answerIndex: 1,
    explanation:
      "The runtime enforces that only the owning program can change an account’s data (and generally its size).",
    deepDive:
      "This is the core safety invariant that enables parallelism and composability without global locks.",
  },
  {
    id: "Q005",
    section: "Accounts & Ownership",
    tags: ["accounts", "locking"],
    difficulty: "advanced",
    prompt: "What is the practical effect of declaring an account as writable in a transaction?",
    choices: [
      "It becomes a signer for the duration of the transaction",
      "It receives a higher compute-unit budget",
      "It is placed under an exclusive write lock during execution",
      "It can be accessed by programs without being passed in the account list",
    ],
    answerIndex: 2,
    explanation:
      "Writable accounts are write-locked for the duration of the transaction, preventing parallel writes that would break consistency.",
    deepDive: "This is the foundation of Solana’s parallel execution model—explicit conflict sets.",
  },
  {
    id: "Q006",
    section: "Accounts & Ownership",
    tags: ["accounts", "sysvar"],
    difficulty: "foundation",
    prompt: "Sysvar accounts are best described as…",
    choices: [
      "Writable system accounts used for rent collection",
      "Read-only accounts containing network/runtime data",
      "User-created accounts for program configuration",
      "Special PDAs owned by the system program",
    ],
    answerIndex: 1,
    explanation:
      "Sysvars are read-only accounts maintained by the runtime containing metadata (clock, epoch schedule, rent, etc.).",
    deepDive: "They’re accessed like normal accounts but are populated by the runtime.",
  },
  {
    id: "Q007",
    section: "Accounts & Ownership",
    tags: ["accounts", "discriminator"],
    difficulty: "expert",
    prompt: "Why do many programs store an account discriminator at the start of account data?",
    choices: [
      "To reduce account size",
      "To prevent signature replay",
      "To identify account type/layout quickly",
      "To enable CPI",
    ],
    answerIndex: 2,
    explanation:
      "A discriminator lets programs safely parse the data by confirming the expected layout before deserialization.",
    deepDive: "Anchor formalizes this pattern, but it’s common across custom programs too.",
  },
  {
    id: "Q008",
    section: "Accounts & Ownership",
    tags: ["accounts", "serialization"],
    difficulty: "expert",
    prompt: "What is a typical reason to keep account data layouts fixed and versioned?",
    choices: [
      "To avoid paying priority fees",
      "To allow schema evolution without breaking old state",
      "To make accounts signer-authorized",
      "To reduce account locking",
    ],
    answerIndex: 1,
    explanation:
      "Fixed/versioned layouts enable safe migrations and backward compatibility when state evolves.",
    deepDive:
      "You can add version fields or migrate with new accounts to avoid breaking existing users.",
  },
  {
    id: "Q009",
    section: "Transactions & Instructions",
    tags: ["transactions", "accounts"],
    difficulty: "foundation",
    prompt: "Why must all accounts a transaction will touch be listed up front?",
    choices: [
      "To allow the runtime to prefetch account data from the ledger",
      "To allow the runtime to precompute signatures without account metas",
      "To enable parallel execution via deterministic lock ordering",
      "To allow programs to add new accounts during execution",
    ],
    answerIndex: 2,
    explanation:
      "The runtime uses the account list to lock and schedule transactions in parallel safely.",
    deepDive: "This up-front declaration is why Solana can scale without a global state lock.",
  },
  {
    id: "Q010",
    section: "Transactions & Instructions",
    tags: ["transactions", "instructions"],
    difficulty: "foundation",
    prompt: "What uniquely defines an instruction (vs the whole transaction)?",
    choices: [
      "A fee payer plus a recent blockhash",
      "A program id, its account metas, and instruction data bytes",
      "A set of signatures over the transaction message",
      "The union of all accounts touched by every instruction",
    ],
    answerIndex: 1,
    explanation:
      "An instruction targets a single program and includes the accounts it will access plus arbitrary data interpreted by that program.",
    deepDive:
      "Transactions bundle instructions plus signatures, blockhash, and fee payer. Instructions are the runtime’s generic “call a program with these accounts and bytes.”",
  },
  {
    id: "Q011",
    section: "Transactions & Instructions",
    tags: ["transactions", "atomicity"],
    difficulty: "advanced",
    prompt: "A Solana transaction with multiple instructions is…",
    choices: [
      "Earlier instructions remain committed if a later one fails",
      "All instructions succeed or the transaction is rolled back as a unit",
      "Each instruction commits independently within the same transaction",
      "Atomicity depends on the cluster type (devnet vs mainnet)",
    ],
    answerIndex: 1,
    explanation:
      "Transactions are atomic: if any instruction fails, all state changes are rolled back.",
    deepDive:
      "This makes multi-instruction flows safe but increases compute and account footprint.",
  },
  {
    id: "Q012",
    section: "Transactions & Instructions",
    tags: ["transactions", "signers"],
    difficulty: "advanced",
    prompt: "What does it mean for an account to be marked as a signer in Solana?",
    choices: [
      "The account is marked writable in the message",
      "A signature by that account’s private key was verified for the message",
      "The account is owned by the system program",
      "The account can be mutated by any program",
    ],
    answerIndex: 1,
    explanation:
      "A signer is an account whose signature over the transaction message was verified. It says nothing by itself about ownership or writability.",
    deepDive:
      "Common bug: treating signer as allowed to write. On Solana these are orthogonal: signer proves authorization, owner controls data writes, and writability controls locking.",
  },
  {
    id: "Q013",
    section: "Transactions & Instructions",
    tags: ["transactions", "replay"],
    difficulty: "advanced",
    prompt: "Why does Solana require a recent blockhash in a transaction?",
    choices: [
      "To select the slot leader for execution",
      "To limit transaction lifetime and prevent replay across slots",
      "To increase parallelism by ordering account locks",
      "To identify the fee payer for the transaction",
    ],
    answerIndex: 1,
    explanation: "Recent blockhashes bound transaction validity and prevent indefinite replay.",
    deepDive: "Durable nonce accounts extend this lifetime for specific use cases.",
  },
  {
    id: "Q014",
    section: "Transactions & Instructions",
    tags: ["transactions", "nonce"],
    difficulty: "expert",
    prompt: "What is the primary purpose of a durable nonce account?",
    choices: [
      "Increase the compute-unit cap for a transaction",
      "Provide a durable recent blockhash so a transaction can be submitted later",
      "Allow CPI calls without extra signatures",
      "Store program-owned state data",
    ],
    answerIndex: 1,
    explanation:
      "Durable nonces let you sign transactions ahead of time by using a nonce value instead of a recent blockhash.",
    deepDive: "Useful for offline signing or delayed submission.",
  },
  {
    id: "Q015",
    section: "Transactions & Instructions",
    tags: ["transactions", "size"],
    difficulty: "advanced",
    prompt: "Why do legacy transactions struggle with very large account lists?",
    choices: [
      "The legacy message has a hard size limit and each account key consumes bytes",
      "Legacy messages restrict how many instructions can be included",
      "Legacy messages require address lookup tables to list accounts",
      "Legacy runtime rejects transactions with a fixed max account count",
    ],
    answerIndex: 0,
    explanation:
      "Legacy message size is limited and account keys dominate size. That’s why v0 transactions + ALTs exist: they reduce the byte cost of large account lists.",
    deepDive: "ALTs solve address bytes, not compute, CPI depth, or overall runtime limits.",
  },
  {
    id: "Q016",
    section: "Transactions & Instructions",
    tags: ["transactions", "priority"],
    difficulty: "advanced",
    prompt: "What does a Compute Budget instruction primarily control?",
    choices: [
      "Rent rate for accounts",
      "Number of required signers",
      "Compute unit limit and unit price for the transaction",
      "Blockhash lifetime and expiration",
    ],
    answerIndex: 2,
    explanation:
      "Compute Budget instructions let you set requested compute units and unit price (priority fee).",
    deepDive: "These influence scheduling and inclusion under congestion.",
  },
  {
    id: "Q017",
    section: "PDAs & Signers",
    tags: ["pda", "signing"],
    difficulty: "foundation",
    prompt: "What is a Program-Derived Address (PDA)?",
    choices: [
      "A deterministic address derived from seeds and program id that is off-curve, so no private key exists",
      "A keypair deterministically generated by the program at runtime and stored on-chain",
      "A normal keypair whose public key is marked as a signer by the runtime",
      "A validator-controlled account used for voting and rewards",
    ],
    answerIndex: 0,
    explanation:
      "PDAs are deterministic and derived from seeds + program ID; they’re constructed so they aren’t backed by a normal private key.",
    deepDive:
      "Programs don’t have keys. They prove PDA derivation (seeds + bump) to the runtime when they need PDA signing semantics.",
  },
  {
    id: "Q018",
    section: "PDAs & Signers",
    tags: ["pda", "invoke_signed"],
    difficulty: "advanced",
    prompt: "How does a program ‘sign’ for a PDA?",
    choices: [
      "It generates a temporary private key during execution",
      "It provides PDA seeds and bump to invoke_signed for runtime verification",
      "It reuses the fee payer’s signature",
      "It hashes the recent blockhash into a signature",
    ],
    answerIndex: 1,
    explanation:
      "The runtime allows the program to act as signer if it proves the PDA via seeds + bump in invoke_signed.",
    deepDive: "Programs don’t own keys; they prove derivation to receive signing authority.",
  },
  {
    id: "Q019",
    section: "PDAs & Signers",
    tags: ["pda", "security"],
    difficulty: "advanced",
    prompt: "If an attacker can guess your PDA seeds, what is the real risk?",
    choices: [
      "They can sign for the PDA because seed knowledge implies key control",
      "They can derive the address, but signing still depends on your program’s validation",
      "They can reassign the PDA to a different program id via CPI",
      "They can flip the PDA on-curve and recover a private key",
    ],
    answerIndex: 1,
    explanation:
      "Seed knowledge lets anyone compute the address. That’s not enough to sign. The danger is when programs don’t validate expected addresses/owners/initialization and accept attacker-supplied accounts.",
    deepDive:
      "Defend with: derive expected PDA inside the program, compare addresses, check owner, check discriminator/init flags, and use canonical seeds.",
  },
  {
    id: "Q020",
    section: "PDAs & Signers",
    tags: ["pda", "bump"],
    difficulty: "foundation",
    prompt: "Why do PDAs need a ‘bump’ seed?",
    choices: [
      "To increase compute budget for PDA creation",
      "To find an off-curve derivation for the seed set",
      "To allow CPI through the system program",
      "To prevent rent collection on PDA accounts",
    ],
    answerIndex: 1,
    explanation:
      "The bump is adjusted to find an address that is off the ed25519 curve (i.e., not a valid pubkey).",
    deepDive: "It’s a brute-force search for a safe PDA derivation.",
  },
  {
    id: "Q021",
    section: "PDAs & Signers",
    tags: ["pda", "design"],
    difficulty: "expert",
    prompt: "Which PDA design best reduces account contention?",
    choices: [
      "One global PDA for all users",
      "A PDA per user or per position",
      "A PDA per program version",
      "A PDA per validator",
    ],
    answerIndex: 1,
    explanation: "Per-user or per-position PDAs localize writes and maximize parallelism.",
    deepDive: "Account modeling is the performance strategy in Solana.",
  },
  {
    id: "Q022",
    section: "PDAs & Signers",
    tags: ["pda", "authority"],
    difficulty: "advanced",
    prompt: "Which is a common PDA authority pattern?",
    choices: [
      "A PDA owns a token account and the program signs via invoke_signed",
      "A PDA holds a private key and signs like a normal wallet",
      "The token mint signs transfers on behalf of the PDA",
      "The PDA appears as a signer in the outer transaction",
    ],
    answerIndex: 0,
    explanation:
      "Programs often set a PDA as token account owner, then sign on its behalf using invoke_signed.",
    deepDive: "This avoids private key custody while enabling program-controlled funds.",
  },
  {
    id: "Q023",
    section: "Programs & CPI",
    tags: ["cpi", "programs"],
    difficulty: "foundation",
    prompt: "In CPI (cross-program invocation), what is the most important mental model?",
    choices: [
      "CPI lets a program invoke another program using the accounts and privileges it already has",
      "CPI lets a program fetch arbitrary accounts from RPC during execution",
      "CPI upgrades the callee’s account metas to writable",
      "CPI requires both programs to share an upgrade authority",
    ],
    answerIndex: 0,
    explanation:
      "CPI is program-to-program calling within a transaction, but the caller cannot conjure accounts or privileges it wasn’t given.",
    deepDive:
      "This is the composability rule that prevents privilege escalation: everything the callee touches must be passed explicitly and must respect the outer transaction’s privileges.",
  },
  {
    id: "Q024",
    section: "Programs & CPI",
    tags: ["cpi", "privilege"],
    difficulty: "advanced",
    prompt: "What is a key CPI privilege rule?",
    choices: [
      "CPI can escalate signer privileges beyond the outer message",
      "CPI passes along equal or lower signer/writable privileges",
      "CPI ignores account metadata when invoked",
      "CPI requires the system program in every account list",
    ],
    answerIndex: 1,
    explanation:
      "Programs cannot arbitrarily escalate privileges in CPI; they can only pass along signers/writability they received.",
    deepDive: "This prevents privilege escalation across program boundaries.",
  },
  {
    id: "Q025",
    section: "Programs & CPI",
    tags: ["programs", "bpf"],
    difficulty: "foundation",
    prompt: "What do validators actually execute when they run a Solana program?",
    choices: [
      "The program’s Rust source compiled just-in-time by validators",
      "An sBPF (Solana BPF) ELF binary verified and run in a sandbox",
      "A WASM module executed by a validator-hosted runtime",
      "JVM bytecode executed by a validator-embedded VM",
    ],
    answerIndex: 1,
    explanation:
      "On-chain programs are compiled to sBPF and deployed as ELF; the runtime verifies and executes them in a sandbox.",
    deepDive:
      "This is why syscalls exist: programs can’t access OS primitives directly; they call into runtime-provided capabilities.",
  },
  {
    id: "Q026",
    section: "Programs & CPI",
    tags: ["programs", "upgrade"],
    difficulty: "advanced",
    prompt: "What enables upgradable programs on Solana?",
    choices: [
      "The system program plus a program upgrade flag",
      "The BPF Loader Upgradeable program",
      "The vote program and vote account authority",
      "Feature gates enforced by cluster governance",
    ],
    answerIndex: 1,
    explanation:
      "Upgradeable programs are managed by the BPF Loader Upgradeable program and an upgrade authority.",
    deepDive: "Program upgrades are themselves transactions controlled by the upgrade authority.",
  },
  {
    id: "Q027",
    section: "Programs & CPI",
    tags: ["programs", "ownership"],
    difficulty: "advanced",
    prompt: "Who can change an account’s owner?",
    choices: [
      "Any signer listed in the transaction",
      "The system program under its assign/create rules (with account authorization)",
      "Any program that performs CPI",
      "Validator software during block production",
    ],
    answerIndex: 1,
    explanation:
      "Ownership is set/changed via system program instructions and requires the account to authorize the change. Programs can’t arbitrarily reassign accounts they don’t control.",
    deepDive: "In practice, ownership is usually set at creation and rarely changed afterward.",
  },
  {
    id: "Q028",
    section: "Programs & CPI",
    tags: ["programs", "idl"],
    difficulty: "expert",
    prompt: "Why do many teams generate client SDKs from IDLs?",
    choices: [
      "To auto-reorder accounts for better parallelism",
      "To ensure typed instruction encoding/decoding and layouts",
      "To reduce on-chain compute usage",
      "To bypass signature checks at runtime",
    ],
    answerIndex: 1,
    explanation:
      "IDL-based clients provide typed, consistent instruction serialization, reducing client bugs.",
    deepDive: "Tools like Anchor/Codama automate this step.",
  },
  {
    id: "Q029",
    section: "Programs & CPI",
    tags: ["programs", "sysvars"],
    difficulty: "foundation",
    prompt: "How do programs typically access cluster metadata like slot/epoch?",
    choices: [
      "By calling the system program to fetch slot/epoch",
      "Via sysvar accounts passed into the instruction",
      "By issuing an RPC request from inside the program",
      "By reading the vote program’s internal state directly",
    ],
    answerIndex: 1,
    explanation:
      "Programs read sysvar accounts passed into the instruction for clock/epoch/rent info.",
    deepDive: "Sysvars must be provided in the account list like any other account.",
  },
  {
    id: "Q030",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "locking"],
    difficulty: "foundation",
    prompt: "Solana’s parallelism is primarily enabled by…",
    choices: [
      "Speculative execution across forks",
      "Account-level read/write locks on the declared account list",
      "Global optimistic concurrency with rollbacks",
      "Separate chains per program id",
    ],
    answerIndex: 1,
    explanation:
      "The runtime can execute transactions in parallel when their write-locked accounts don’t overlap.",
    deepDive: "This makes account modeling the performance lever.",
  },
  {
    id: "Q031",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "design"],
    difficulty: "advanced",
    prompt: "Which account design best improves parallel throughput?",
    choices: [
      "One global state account shared by all users",
      "Sharded state with one account per user or per market",
      "A single PDA that stores all program state",
      "Store mutable state in sysvar accounts",
    ],
    answerIndex: 1,
    explanation:
      "Sharding state into many accounts reduces write conflicts and unlocks parallelism.",
    deepDive: "Solana throughput is a direct function of account contention.",
  },
  {
    id: "Q032",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "rollback"],
    difficulty: "advanced",
    prompt: "If an instruction fails midway, what happens to account locks?",
    choices: [
      "Locks remain until the next slot boundary",
      "Locks are released and the transaction’s changes are rolled back",
      "Locks downgrade to read-only after the failure",
      "Locks persist so the transaction can be replayed",
    ],
    answerIndex: 1,
    explanation: "The transaction is rolled back and locks are released once execution ends.",
    deepDive: "Atomicity guarantees consistency even under parallel execution.",
  },
  {
    id: "Q033",
    section: "Runtime & Parallelism",
    tags: ["parallelism", "accounts"],
    difficulty: "foundation",
    prompt: "Read-only accounts in a transaction…",
    choices: [
      "Take no locks and can be mutated freely",
      "Use shared/read locks, allowing concurrent readers across transactions",
      "Are upgraded to writable if the program requests it",
      "Must appear as signers to be readable",
    ],
    answerIndex: 1,
    explanation:
      "Read-only accounts can be accessed in parallel by multiple transactions because they take shared/read locks. Only writable accounts take exclusive locks.",
    deepDive:
      "This is why marking accounts writable “just in case” harms throughput: you convert shared locks into exclusive conflicts.",
  },
  {
    id: "Q034",
    section: "Runtime & Parallelism",
    tags: ["compute", "units"],
    difficulty: "advanced",
    prompt: "Compute units (CUs) are best thought of as…",
    choices: [
      "A proxy for network bandwidth consumption",
      "A rough measure of CPU work for a transaction",
      "A limit on heap memory allocation",
      "A count of unique accounts referenced",
    ],
    answerIndex: 1,
    explanation:
      "Compute units measure execution cost; programs must stay within per-transaction limits.",
    deepDive: "You can request higher limits (and pay more) with Compute Budget instructions.",
  },
  {
    id: "Q035",
    section: "Runtime & Parallelism",
    tags: ["compute", "failure"],
    difficulty: "advanced",
    prompt: "What happens when a transaction exceeds its compute limit?",
    choices: [
      "Execution pauses and resumes in the next slot",
      "Execution aborts and state changes are rolled back",
      "The runtime raises the limit for that transaction",
      "Only the last instruction is reverted",
    ],
    answerIndex: 1,
    explanation: "Exceeding the compute limit fails the transaction atomically.",
    deepDive: "This is why compute budgeting and optimization matter.",
  },
  {
    id: "Q036",
    section: "Runtime & Parallelism",
    tags: ["runtime", "syscalls"],
    difficulty: "expert",
    prompt: "Why are syscalls used in Solana programs?",
    choices: [
      "To bypass runtime safety checks and access OS calls",
      "To access runtime-provided functionality like hashing or sysvars",
      "To perform outbound network calls from the program",
      "To set priority fees for the transaction",
    ],
    answerIndex: 1,
    explanation:
      "Syscalls expose runtime-provided capabilities to programs without direct OS access.",
    deepDive: "Examples: hash functions, logging, sysvar access, curve ops.",
  },
  {
    id: "Q037",
    section: "Fees & Compute Budget",
    tags: ["fees", "priority"],
    difficulty: "foundation",
    prompt: "Priority fees are…",
    choices: [
      "A flat fee paid to the system program per transaction",
      "An optional extra paid per compute unit",
      "A requirement for vote transactions",
      "A fee paid in SPL tokens instead of lamports",
    ],
    answerIndex: 1,
    explanation:
      "Priority fees let users bid lamports per compute unit to improve inclusion during congestion.",
    deepDive: "They’re specified in Compute Budget instructions.",
  },
  {
    id: "Q038",
    section: "Fees & Compute Budget",
    tags: ["fees", "compute"],
    difficulty: "advanced",
    prompt: "Why might a transaction include a Compute Budget instruction?",
    choices: [
      "To shrink the transaction’s account list",
      "To request a higher CU limit or set a unit price",
      "To bypass signature checks during execution",
      "To access sysvar accounts without passing them",
    ],
    answerIndex: 1,
    explanation: "Compute Budget lets you request more CUs and/or set a higher unit price.",
    deepDive: "This is crucial for heavy transactions under load.",
  },
  {
    id: "Q039",
    section: "Fees & Compute Budget",
    tags: ["fees", "payer"],
    difficulty: "foundation",
    prompt: "Who pays transaction fees on Solana?",
    choices: [
      "The program being called pays from its program account",
      "The fee payer account specified in the transaction",
      "The last writable account listed in the message",
      "The leader validator for the slot",
    ],
    answerIndex: 1,
    explanation: "The fee payer is an explicit signer in the transaction.",
    deepDive: "Fee payer can be any signer, not necessarily the user who initiated the action.",
  },
  {
    id: "Q040",
    section: "Fees & Compute Budget",
    tags: ["fees", "cost"],
    difficulty: "advanced",
    prompt: "Which factor most directly increases transaction cost under fee markets?",
    choices: [
      "Number of instructions in the message",
      "Compute units requested multiplied by unit price",
      "Number of read-only accounts in the message",
      "Presence of PDAs in the account list",
    ],
    answerIndex: 1,
    explanation: "Cost scales with requested compute units and the price per unit (priority fee).",
    deepDive: "This is separate from base fees.",
  },
  {
    id: "Q041",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "foundation",
    prompt: "What does the SPL Token program standardize on Solana?",
    choices: [
      "Consensus rules for validators and fork choice",
      "Fungible token mint and token account state transitions (mint, transfer, burn, approve)",
      "Wallet seed phrase and key-derivation formats",
      "Transaction fee markets and priority fee rules",
    ],
    answerIndex: 1,
    explanation: "It standardizes token mechanics and account layouts for fungible tokens.",
    deepDive:
      "Like ERC-20 in concept, but implemented via explicit accounts (mint + token accounts) and program-owned state.",
  },
  {
    id: "Q042",
    section: "Token Programs",
    tags: ["tokens", "ata"],
    difficulty: "foundation",
    prompt: "What makes an Associated Token Account (ATA) valuable for UX?",
    choices: [
      "It is a special token account type required to hold SPL tokens",
      "It is a deterministic token account address for (wallet, mint, token program), so wallets can find balances predictably",
      "It is a sysvar maintained by the runtime for token balances",
      "It signs transfers on behalf of the wallet",
    ],
    answerIndex: 1,
    explanation:
      "ATAs are deterministic, so clients don’t need discovery/indexing to locate the “standard” account for a wallet’s token balance.",
    deepDive:
      "The deterministic address idea is why ATAs reduce UX friction—but you still must use the correct token program (classic vs Token-2022).",
  },
  {
    id: "Q043",
    section: "Token Programs",
    tags: ["tokens", "authority"],
    difficulty: "advanced",
    prompt: "Which is a typical token authority pattern?",
    choices: [
      "Wallet owns a token account and the program signs with the wallet key",
      "PDA owns a token account and the program uses invoke_signed for transfers",
      "Token mint signs transfers as the authority",
      "A sysvar account owns token accounts and authorizes transfers",
    ],
    answerIndex: 1,
    explanation:
      "Program-controlled token accounts usually use a PDA as owner and invoke_signed for transfers.",
    deepDive: "This enables secure escrow and vault designs.",
  },
  {
    id: "Q044",
    section: "Token Programs",
    tags: ["token-2022", "extensions"],
    difficulty: "advanced",
    prompt: "Token-2022 primarily adds…",
    choices: [
      "A new consensus mechanism for validators",
      "Extensions such as transfer hooks, metadata, memo, and interest",
      "Mandatory KYC enforced at the protocol layer",
      "Shorter finality times for blocks",
    ],
    answerIndex: 1,
    explanation: "Token-2022 adds extensible features (transfer hooks, metadata, interest, etc.).",
    deepDive: "It’s a superset of SPL Token with optional extensions.",
  },
  {
    id: "Q045",
    section: "Token Programs",
    tags: ["token-2022", "compat"],
    difficulty: "advanced",
    prompt: "A common pitfall with Token-2022 is…",
    choices: [
      "ATAs are not supported for Token-2022 mints",
      "Clients must use the correct token program ID",
      "Token-2022 disables minting instructions",
      "Token-2022 requires validator votes for transfers",
    ],
    answerIndex: 1,
    explanation: "Token-2022 uses a different program ID; clients must target the correct program.",
    deepDive: "Mixing program IDs causes signature/ownership failures.",
  },
  {
    id: "Q046",
    section: "Token Programs",
    tags: ["tokens", "mint"],
    difficulty: "foundation",
    prompt: "What does a token mint account represent?",
    choices: [
      "A ledger of every token holder’s balance",
      "Global configuration, authorities, and supply metadata for a token type",
      "A wallet’s consolidated token portfolio",
      "An RPC-side index of token transfers",
    ],
    answerIndex: 1,
    explanation:
      "Mints define the token type (decimals, supply, authorities). Individual balances live in token accounts.",
    deepDive:
      "This separation (mint vs token accounts) is why “one balance per wallet” is not implicit on Solana—ATAs make it conventional.",
  },
  {
    id: "Q047",
    section: "Token Programs",
    tags: ["tokens", "freeze"],
    difficulty: "expert",
    prompt: "What is the purpose of a freeze authority?",
    choices: [
      "To sign recent blockhashes for the mint",
      "To freeze token accounts and block transfers",
      "To change validator votes for the mint",
      "To disable CPI for that token program",
    ],
    answerIndex: 1,
    explanation: "A freeze authority can freeze token accounts to halt transfers for that mint.",
    deepDive: "Often used for compliance or emergency controls.",
  },
  {
    id: "Q048",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "v0"],
    difficulty: "foundation",
    prompt: "Why were versioned (v0) transactions introduced?",
    choices: [
      "To replace signatures with hash commitments",
      "To enable Address Lookup Tables and larger account lists",
      "To remove recent blockhashes from messages",
      "To make programs upgradable",
    ],
    answerIndex: 1,
    explanation:
      "v0 transactions support ALTs, which compress account lists for large transactions.",
    deepDive: "This enables complex multi-program workflows.",
  },
  {
    id: "Q049",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "compression"],
    difficulty: "advanced",
    prompt: "How do ALTs reduce transaction size?",
    choices: [
      "By hashing instruction data into shorter forms",
      "By storing addresses on-chain and referencing them by index",
      "By omitting account metas from the message",
      "By compressing signatures into fewer bytes",
    ],
    answerIndex: 1,
    explanation:
      "ALTs store addresses on-chain so transactions can reference them by small indexes.",
    deepDive: "This reduces the byte cost of large account lists.",
  },
  {
    id: "Q050",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "authority"],
    difficulty: "advanced",
    prompt: "Who controls an ALT’s contents?",
    choices: [
      "Any program that references the table",
      "Its authority set at creation",
      "The system program for the cluster",
      "The fee payer of the transaction",
    ],
    answerIndex: 1,
    explanation: "Each ALT has an authority that can extend, deactivate, or close it.",
    deepDive: "This prevents arbitrary tampering with lookup tables.",
  },
  {
    id: "Q051",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "use"],
    difficulty: "foundation",
    prompt: "Which transaction types can use ALTs?",
    choices: [
      "Legacy transactions",
      "v0 (versioned) transactions",
      "Both legacy and v0 transactions",
      "Vote transactions",
    ],
    answerIndex: 1,
    explanation: "ALTs are supported only in v0 (versioned) transactions.",
    deepDive: "Legacy transactions have fixed account list size limits.",
  },
  {
    id: "Q052",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "pitfall"],
    difficulty: "expert",
    prompt: "A common ALT pitfall is…",
    choices: [
      "ALT-resolved addresses must be read-only",
      "You must include the ALT account itself in the tx message",
      "ALT contents are mutable by anyone who references it",
      "ALTs replace instruction data in the message",
    ],
    answerIndex: 1,
    explanation:
      "The ALT account must be referenced in the transaction so the runtime can load it.",
    deepDive: "Missing the ALT account results in address resolution failures.",
  },
  {
    id: "Q053",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "slots"],
    difficulty: "foundation",
    prompt: "In Solana, a “slot” is best understood as…",
    choices: [
      "A finalized block committed by supermajority",
      "A scheduled leader window in which a leader produces entries/blocks",
      "A single transaction plus its signature",
      "A validator vote message for consensus",
    ],
    answerIndex: 1,
    explanation:
      "Slots are time windows assigned to leaders. Blocks/entries are produced during slots; finality is a separate concept.",
    deepDive:
      "This is why leaders can influence ordering within their slot: scheduling is explicit.",
  },
  {
    id: "Q054",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "ordering"],
    difficulty: "advanced",
    prompt: "Proof of History (PoH) is most usefully thought of as…",
    choices: [
      "A finality gadget used for fork choice",
      "A verifiable ordering/clock primitive used to sequence events efficiently",
      "A slashing system for dishonest validators",
      "A randomness beacon for leader selection",
    ],
    answerIndex: 1,
    explanation:
      "PoH provides a verifiable sequence that helps order events without requiring everyone to agree on timestamps.",
    deepDive:
      "PoH helps with ordering/verification speed; consensus/finality still comes from stake-weighted voting.",
  },
  {
    id: "Q055",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "finality"],
    difficulty: "advanced",
    prompt: "What is the difference between ‘confirmed’ and ‘finalized’?",
    choices: [
      "Confirmed is irreversible while finalized can still revert",
      "Finalized has stronger consensus weight and is very unlikely to revert",
      "Confirmed and finalized are identical",
      "Confirmed means all validators have voted",
    ],
    answerIndex: 1,
    explanation:
      "Finalized has stronger BFT consensus weight and is extremely unlikely to revert compared to confirmed.",
    deepDive: "Use finalized for high-value actions; confirmed is often fine for UX.",
  },
  {
    id: "Q056",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "votes"],
    difficulty: "advanced",
    prompt: "What role do vote accounts play?",
    choices: [
      "They store token balances for stakers",
      "They cast votes on forks and earn rewards",
      "They store program data for upgrades",
      "They track address lookup tables",
    ],
    answerIndex: 1,
    explanation:
      "Vote accounts are used by validators to vote on the fork choice and collect rewards.",
    deepDive: "Stake weight and voting drive consensus.",
  },
  {
    id: "Q057",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "stake"],
    difficulty: "foundation",
    prompt: "Consensus weight in Solana is primarily based on…",
    choices: [
      "Compute units consumed in the epoch",
      "Stake weight delegated to validators",
      "Number of transactions processed",
      "CPU cores per validator",
    ],
    answerIndex: 1,
    explanation: "Stake weight determines voting power and leader schedule priority.",
    deepDive: "This is standard for PoS systems.",
  },
  {
    id: "Q058",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "security"],
    difficulty: "expert",
    prompt: "PoH does NOT directly guarantee…",
    choices: [
      "Event ordering of hashes and entries",
      "A cryptographic clock for sequencing",
      "Whether a leader is honest about when they saw transactions",
      "Faster signature verification by itself",
    ],
    answerIndex: 2,
    explanation:
      "PoH provides ordering and a clock, but it doesn’t prove when a leader actually received a transaction.",
    deepDive: "This is why MEV and leader control are still relevant.",
  },
  {
    id: "Q059",
    section: "Validator Pipeline & Networking",
    tags: ["tpu", "network"],
    difficulty: "foundation",
    prompt: "If your transaction never seems to reach a leader, which subsystem is most relevant?",
    choices: [
      "TPU (ingest/schedule path)",
      "TVU (replay/verification path)",
      "Rent sysvar",
      "BPF loader",
    ],
    answerIndex: 0,
    explanation:
      "TPU is the hot path for transaction ingestion and forwarding toward leaders for inclusion.",
    deepDive:
      "TVU is about replaying blocks you received; TPU is about getting your tx into the pipeline.",
  },
  {
    id: "Q060",
    section: "Validator Pipeline & Networking",
    tags: ["tvu", "network"],
    difficulty: "advanced",
    prompt: "The TVU (Transaction Validation Unit) primarily handles…",
    choices: [
      "Ingesting transactions from clients into the leader pipeline",
      "Verifying and replaying blocks to update state",
      "Estimating fees and compute budgets",
      "Creating and assigning new accounts on-chain",
    ],
    answerIndex: 1,
    explanation: "The TVU verifies and replays blocks produced by leaders to update state.",
    deepDive: "This keeps validators in sync with the ledger.",
  },
  {
    id: "Q061",
    section: "Validator Pipeline & Networking",
    tags: ["quic", "qos"],
    difficulty: "advanced",
    prompt: "Why was QUIC adopted for transaction ingestion?",
    choices: [
      "It enables smart contracts in the TPU pipeline",
      "It provides better flow control and resilience under load",
      "It removes signatures from packet payloads",
      "It accelerates PoH hashing for leaders",
    ],
    answerIndex: 1,
    explanation: "QUIC improves flow control and robustness for packetized transaction ingest.",
    deepDive: "It helps reduce spam impact and improves stability.",
  },
  {
    id: "Q062",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "stake"],
    difficulty: "advanced",
    prompt: "Stake-weighted QoS means…",
    choices: [
      "All packets are treated equally regardless of stake",
      "Traffic from staked validators/RPCs gets priority",
      "Transaction submission is limited to validators",
      "Fees are ignored during scheduling",
    ],
    answerIndex: 1,
    explanation: "Stake-weighted QoS prioritizes packets from staked validators or their peers.",
    deepDive: "This improves spam resistance during congestion.",
  },
  {
    id: "Q063",
    section: "Validator Pipeline & Networking",
    tags: ["gossip", "cluster"],
    difficulty: "foundation",
    prompt: "Gossip is primarily used to…",
    choices: [
      "Execute transactions for user programs",
      "Propagate cluster metadata (peers, votes, leader schedule info, etc.)",
      "Store account state snapshots for fast boot",
      "Route CPI calls between programs",
    ],
    answerIndex: 1,
    explanation:
      "Gossip is the cluster’s “who’s here and what’s happening” propagation layer, not the execution engine.",
    deepDive:
      "It’s why nodes can discover each other and share state-of-the-network info without centralized coordination.",
  },
  {
    id: "Q064",
    section: "Validator Pipeline & Networking",
    tags: ["turbine", "shreds"],
    difficulty: "expert",
    prompt: "Turbine’s role is to…",
    choices: [
      "Sign transactions on behalf of users",
      "Efficiently broadcast blocks via shreds",
      "Compute transaction fees",
      "Store snapshots for fast restart",
    ],
    answerIndex: 1,
    explanation: "Turbine is Solana’s block propagation protocol using shreds.",
    deepDive: "It reduces bandwidth requirements compared to naive broadcast.",
  },
  {
    id: "Q065",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "foundation",
    prompt: "Commitment levels in RPC allow clients to…",
    choices: [
      "Choose token programs for instruction encoding",
      "Select how finalized the queried data should be",
      "Set compute limits for transactions",
      "Bypass fees on RPC calls",
    ],
    answerIndex: 1,
    explanation: "Commitment levels control how finalized/confirmed the data should be.",
    deepDive: "Clients can trade speed for finality.",
  },
  {
    id: "Q066",
    section: "RPC & Client Behavior",
    tags: ["rpc", "simulation"],
    difficulty: "advanced",
    prompt: "Why simulate transactions before sending?",
    choices: [
      "To bypass fees for failed transactions",
      "To detect errors and estimate logs/compute before sending",
      "To finalize immediately without voting",
      "To change the recent blockhash on-chain",
    ],
    answerIndex: 1,
    explanation: "Simulation reveals errors, logs, and compute usage without committing state.",
    deepDive: "It’s essential for debugging and fee tuning.",
  },
  {
    id: "Q067",
    section: "RPC & Client Behavior",
    tags: ["rpc", "websocket"],
    difficulty: "advanced",
    prompt: "When should you prefer WebSocket subscriptions over polling?",
    choices: [
      "When you can tolerate slower, periodic updates from polling",
      "When you need near-real-time account updates",
      "When you need data for a small set of token accounts",
      "When you are tracking vote accounts for consensus",
    ],
    answerIndex: 1,
    explanation: "WebSocket subscriptions deliver near-real-time updates without heavy polling.",
    deepDive: "This reduces RPC load and latency for live UX.",
  },
  {
    id: "Q068",
    section: "RPC & Client Behavior",
    tags: ["rpc", "retries"],
    difficulty: "advanced",
    prompt: "A robust client should retry on…",
    choices: [
      "All errors with the same retry policy",
      "Transient errors like blockhash not found or node timeouts",
      "Signature verification failures from invalid signers",
      "Program errors like custom error codes",
    ],
    answerIndex: 1,
    explanation:
      "Transient network errors or blockhash expiry are common; retries with a fresh blockhash help.",
    deepDive: "Program errors should usually not be retried without changes.",
  },
  {
    id: "Q069",
    section: "RPC & Client Behavior",
    tags: ["rpc", "finality"],
    difficulty: "expert",
    prompt: "Why might a transaction be ‘confirmed’ but later not finalized?",
    choices: [
      "Confirmed has stronger finality than finalized",
      "Forks can still occur before finality thresholds are reached",
      "Validators ignore confirmed blocks in voting",
      "The behavior is a devnet-specific artifact",
    ],
    answerIndex: 1,
    explanation:
      "Confirmed data can still be on a fork that doesn’t reach finality; finalized is stronger.",
    deepDive: "This is rare but important for high-value operations.",
  },
  {
    id: "Q070",
    section: "RPC & Client Behavior",
    tags: ["rpc", "data"],
    difficulty: "foundation",
    prompt: "Account data fetched from RPC is…",
    choices: [
      "Guaranteed to be final and irreversible",
      "Dependent on the commitment level of the request",
      "Encrypted by default for privacy",
      "Unaffected by forks or reorgs",
    ],
    answerIndex: 1,
    explanation:
      "RPC responses depend on commitment levels and can be affected by forks pre-finality.",
    deepDive: "Use higher commitment for critical reads.",
  },
  {
    id: "Q071",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "feature-gates"],
    difficulty: "advanced",
    prompt: "In Solana, when is a protocol change actually live?",
    choices: [
      "When a SIMD is merged into the repository",
      "When the validator release is published",
      "When the feature gate is activated on-chain",
      "When documentation is updated and announced",
    ],
    answerIndex: 2,
    explanation:
      "The real switch is feature-gate activation; releases can ship code before activation.",
    deepDive: "This enables staged rollouts across clusters.",
  },
  {
    id: "Q072",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "process"],
    difficulty: "foundation",
    prompt: "What makes SIMDs useful in the Solana ecosystem?",
    choices: [
      "They are validator-executed code that flips feature gates",
      "They are proposal documents that track design rationale and lifecycle",
      "They are mandatory for program upgrades",
      "They are a governance token standard",
    ],
    answerIndex: 1,
    explanation:
      "SIMDs are the design/process artifact; activation is handled separately via feature gates.",
    deepDive: "This teaches “paper accepted” ≠ “feature live,” which is core in Solana operations.",
  },
  {
    id: "Q073",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "activation"],
    difficulty: "advanced",
    prompt: "Why use feature gates?",
    choices: [
      "To hide unfinished code from validators",
      "To activate changes safely and sequentially",
      "To skip testing of consensus changes",
      "To replace on-chain governance",
    ],
    answerIndex: 1,
    explanation: "Feature gates allow controlled, staged activation of protocol changes.",
    deepDive: "They decouple code shipping from on-chain activation.",
  },
  {
    id: "Q074",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["release", "validator"],
    difficulty: "advanced",
    prompt: "Why might validators upgrade before a feature is active?",
    choices: [
      "Validators are forced by the runtime to upgrade immediately",
      "The feature is behind a gate and can be activated later",
      "It reduces their fees during upgrade",
      "It changes consensus rules as soon as binaries restart",
    ],
    answerIndex: 1,
    explanation:
      "Validators often upgrade to a version that includes gated features that activate later.",
    deepDive: "This is standard staged rollout practice.",
  },
  {
    id: "Q075",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["forks", "activation"],
    difficulty: "expert",
    prompt: "What’s a risk if validators activate a feature without network readiness?",
    choices: [
      "Activation is risk-free even if versions diverge",
      "Potential forks or instability if versions diverge",
      "Fees drop to zero for the epoch",
      "Transactions become free for all users",
    ],
    answerIndex: 1,
    explanation: "Activation before broad upgrade can cause divergence or instability.",
    deepDive: "This is why activation schedules are conservative.",
  },
  {
    id: "Q076",
    section: "Security & Pitfalls",
    tags: ["security", "signers"],
    difficulty: "foundation",
    prompt: "What is a common security pitfall in Solana programs?",
    choices: [
      "Verifying account ownership and signer flags before mutating data",
      "Failing to check account ownership or signer status on critical accounts",
      "Using PDAs for program state",
      "Reading sysvars for cluster metadata",
    ],
    answerIndex: 1,
    explanation: "Not validating ownership/signers can allow unauthorized mutations.",
    deepDive: "Always assert owners, signers, and expected addresses.",
  },
  {
    id: "Q077",
    section: "Security & Pitfalls",
    tags: ["security", "replay"],
    difficulty: "advanced",
    prompt: "Why include nonce or unique seeds in PDA derivations?",
    choices: [
      "To avoid rent collection on PDA accounts",
      "To avoid address collisions and keep PDAs distinct",
      "To increase compute budget during invoke_signed",
      "To enable CPI without extra accounts",
    ],
    answerIndex: 1,
    explanation: "Unique seeds ensure distinct PDAs per user/position and avoid collisions.",
    deepDive: "Deterministic uniqueness reduces state overlap.",
  },
  {
    id: "Q078",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "advanced",
    prompt: "A CPI pitfall is…",
    choices: [
      "Using CPI to call the system program for account creation",
      "Passing extra read-only accounts to reduce borrow checks",
      "Reusing instruction data across CPIs without re-serialization",
      "Forwarding signer or writable accounts to an untrusted callee without validation",
    ],
    answerIndex: 3,
    explanation:
      "CPI requires precise accounts and privilege rules; mistakes lead to failure or security issues.",
    deepDive: "CPI cannot magically elevate privileges.",
  },
  {
    id: "Q079",
    section: "Security & Pitfalls",
    tags: ["security", "logging"],
    difficulty: "foundation",
    prompt: "Why shouldn’t you treat logs as authoritative state?",
    choices: [
      "Logs are encrypted and cannot be read by clients",
      "Logs are hints for debugging/UX, not canonical on-chain state",
      "Logs are required for state changes to be valid",
      "Logs are emitted on devnet but suppressed on mainnet",
    ],
    answerIndex: 1,
    explanation: "Logs are for debugging/UX; canonical state lives in account data.",
    deepDive: "Build on account data, not log parsing.",
  },
  {
    id: "Q080",
    section: "Security & Pitfalls",
    tags: ["security", "reentrancy"],
    difficulty: "expert",
    prompt: "Solana programs are still vulnerable to reentrancy-like issues when…",
    choices: [
      "They call CPI to untrusted programs without state checks or program-id validation",
      "They use PDAs as authorities",
      "They read sysvars during execution",
      "They are written in Rust instead of C",
    ],
    answerIndex: 0,
    explanation:
      "CPI to untrusted programs can introduce reentrancy-like control flow if state is not managed carefully or program IDs aren’t validated.",
    deepDive: "Use checks-effects-interactions and validate expected program IDs.",
  },
  {
    id: "Q081",
    section: "Transactions & Instructions",
    tags: ["instructions", "order"],
    difficulty: "advanced",
    prompt: "Why does instruction order in a transaction matter?",
    choices: [
      "Instruction order has no effect on state",
      "Later instructions can depend on state changes from earlier ones",
      "Instruction order matters for sysvar reads in particular",
      "Instruction order matters for fee calculation in particular",
    ],
    answerIndex: 1,
    explanation:
      "Instructions execute sequentially; later instructions see state changes from earlier ones.",
    deepDive: "This enables complex atomic workflows.",
  },
  {
    id: "Q082",
    section: "Transactions & Instructions",
    tags: ["instructions", "accounts"],
    difficulty: "advanced",
    prompt: "If two instructions in one tx write the same account…",
    choices: [
      "It is rejected because an account can be written a single time",
      "It is allowed; they execute in order within the tx",
      "The account is downgraded to read-only",
      "It must be a PDA to be written twice",
    ],
    answerIndex: 1,
    explanation: "Within a transaction, multiple writes are allowed; the tx is atomic and ordered.",
    deepDive: "Parallelism is across transactions, not within a single one.",
  },
  {
    id: "Q083",
    section: "Transactions & Instructions",
    tags: ["instructions", "limits"],
    difficulty: "expert",
    prompt: "Why can large multi-instruction transactions still fail even with ALTs?",
    choices: [
      "ALTs increase compute limits for each instruction",
      "Compute budget and account limits still apply",
      "ALTs are limited to devnet clusters",
      "Wallets reject any transaction that uses ALTs",
    ],
    answerIndex: 1,
    explanation: "ALTs solve address size, not compute or runtime limits.",
    deepDive: "Compute budget, CPI depth, and account limits still constrain complexity.",
  },
  {
    id: "Q084",
    section: "PDAs & Signers",
    tags: ["pda", "seeds"],
    difficulty: "advanced",
    prompt: "Which seed strategy is safest for a PDA?",
    choices: [
      "A single static seed shared by all users",
      "User pubkey plus a program-specific constant",
      "Recent blockhash to randomize the address",
      "Validator identity for uniqueness",
    ],
    answerIndex: 1,
    explanation: "Combining user pubkey with a constant ensures stable, unique addresses per user.",
    deepDive: "Avoid ephemeral seeds that change unpredictably.",
  },
  {
    id: "Q085",
    section: "PDAs & Signers",
    tags: ["pda", "init"],
    difficulty: "advanced",
    prompt: "When initializing a PDA account, a typical pattern is…",
    choices: [
      "Program allocates and assigns via system program CPI with invoke_signed",
      "Program writes data to the PDA without creating or funding it",
      "User signs for the PDA with their keypair",
      "The PDA signs for itself without invoke_signed",
    ],
    answerIndex: 0,
    explanation: "Programs create PDA accounts via CPI to the system program, using invoke_signed.",
    deepDive: "This ensures proper lamports and ownership assignment.",
  },
  {
    id: "Q086",
    section: "Programs & CPI",
    tags: ["cpi", "accounts"],
    difficulty: "foundation",
    prompt: "If a program needs an account during CPI, it must…",
    choices: [
      "Fetch it from RPC during execution",
      "Receive it from the caller as an account input",
      "Derive it internally without being passed",
      "Use sysvars to load it implicitly",
    ],
    answerIndex: 1,
    explanation:
      "Programs can only access accounts passed into the instruction (and in CPI, passed along).",
    deepDive: "No implicit access to global state.",
  },
  {
    id: "Q087",
    section: "Programs & CPI",
    tags: ["cpi", "signer"],
    difficulty: "advanced",
    prompt: "How can a program authorize a CPI that requires a signer?",
    choices: [
      "By marking the account writable in the message",
      "By using invoke_signed with PDA seeds",
      "By skipping signature checks inside the callee",
      "By paying additional priority fees",
    ],
    answerIndex: 1,
    explanation: "invoke_signed provides PDA-based signing authority for CPI signers.",
    deepDive: "This is the core of PDA authority delegation.",
  },
  {
    id: "Q088",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why is ‘account list’ a scalability bottleneck for some apps?",
    choices: [
      "Because accounts are too small to fit data",
      "Because transaction size limits the number of accounts",
      "Because accounts must be encrypted on chain",
      "Because account lists are randomized by the runtime",
    ],
    answerIndex: 1,
    explanation: "Each account meta costs bytes; large workflows hit size limits without ALTs.",
    deepDive: "ALTs help, but compute and CPI depth still constrain complexity.",
  },
  {
    id: "Q089",
    section: "Runtime & Parallelism",
    tags: ["runtime", "determinism"],
    difficulty: "advanced",
    prompt: "Why must program execution be deterministic?",
    choices: [
      "To reduce fees paid by transactions",
      "So all validators reach the same state",
      "To allow PoH to produce hashes",
      "To improve UX with faster UIs",
    ],
    answerIndex: 1,
    explanation: "Determinism ensures all validators compute identical state transitions.",
    deepDive: "Non-determinism would split consensus.",
  },
  {
    id: "Q090",
    section: "Fees & Compute Budget",
    tags: ["compute", "budget"],
    difficulty: "expert",
    prompt: "Why might requesting too many compute units be counterproductive?",
    choices: [
      "It lowers your unit price without you noticing",
      "It increases cost and may reduce inclusion if too expensive",
      "It increases account limits per transaction",
      "It disables CPI depth limits",
    ],
    answerIndex: 1,
    explanation:
      "Requesting a high CU limit raises max fee (when unit price > 0); under congestion, it can price you out and reduce inclusion likelihood.",
    deepDive: "Tune CU limit and unit price based on workload.",
  },
  {
    id: "Q091",
    section: "Token Programs",
    tags: ["tokens", "extensions"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions require extra account space?",
    choices: [
      "Because extension metadata is stored in the account",
      "Because extensions increase compute usage",
      "Because extensions add new PDAs per mint",
      "Because extensions require sysvar accounts",
    ],
    answerIndex: 0,
    explanation:
      "Extensions store additional data in the token account/mint, requiring extra space.",
    deepDive: "Account size must be allocated to fit extension state.",
  },
  {
    id: "Q092",
    section: "Token Programs",
    tags: ["tokens", "spl"],
    difficulty: "advanced",
    prompt: "Why can a token transfer fail even if the sender has enough balance?",
    choices: [
      "Because token accounts are read-only by default",
      "Because the token program ID or authority is wrong",
      "Because PoH forbids token transfers in the slot",
      "Because CPI is disallowed for token programs",
    ],
    answerIndex: 1,
    explanation:
      "Common failures include wrong token program ID, missing signer, or frozen accounts.",
    deepDive: "Token transfers are authority-checked, not just balance-based.",
  },
  {
    id: "Q093",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "lifecycle"],
    difficulty: "advanced",
    prompt: "What happens when an ALT is deactivated?",
    choices: [
      "All transactions that reference it immediately revert",
      "It becomes non-extendable and will expire after a cooldown",
      "It becomes permanently read-only but never expires",
      "It loses all addresses immediately on deactivation",
    ],
    answerIndex: 1,
    explanation: "Deactivation starts a cooldown period; after that it can be closed.",
    deepDive: "This prevents immediate removal that could break pending transactions.",
  },
  {
    id: "Q094",
    section: "Versioned Transactions & ALTs",
    tags: ["alts", "design"],
    difficulty: "expert",
    prompt: "Why do aggregators maintain multiple ALTs instead of one giant table?",
    choices: [
      "ALTs are capped at five addresses each",
      "Different routes require different account sets; smaller ALTs reduce stale entries",
      "ALTs charge a fee per lookup, so fewer lookups cost less",
      "ALTs are restricted to validators",
    ],
    answerIndex: 1,
    explanation:
      "Route-specific ALTs keep tables focused and avoid unused/stale entries (and ALTs are capped in size).",
    deepDive: "This improves reliability and reduces maintenance overhead.",
  },
  {
    id: "Q095",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "forks"],
    difficulty: "expert",
    prompt: "What causes a fork in Solana?",
    choices: [
      "A blockhash change between slots",
      "Two leaders produce competing blocks for the same slot range",
      "A missing PDA during execution",
      "An RPC timeout at a client",
    ],
    answerIndex: 1,
    explanation: "Forks occur when different validators see different valid blocks or sequences.",
    deepDive: "Consensus resolves forks based on stake-weighted votes.",
  },
  {
    id: "Q096",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "leader"],
    difficulty: "advanced",
    prompt: "How is the leader schedule determined?",
    choices: [
      "By random selection per transaction",
      "By stake-weighted deterministic schedule",
      "By the fee payer of each transaction",
      "By a sysvar computed at runtime",
    ],
    answerIndex: 1,
    explanation: "Leader schedule is deterministic and stake-weighted over epochs.",
    deepDive: "This makes leader assignment predictable but weighted by stake.",
  },
  {
    id: "Q097",
    section: "Validator Pipeline & Networking",
    tags: ["shreds", "data"],
    difficulty: "advanced",
    prompt: "Why are blocks split into shreds?",
    choices: [
      "To hide data from non-leader validators",
      "To enable efficient propagation and repair",
      "To reduce compute unit usage",
      "To simplify CPI routing",
    ],
    answerIndex: 1,
    explanation: "Shreds allow parallel distribution and repair of block data via Turbine.",
    deepDive: "It’s a key scalability mechanism.",
  },
  {
    id: "Q098",
    section: "Validator Pipeline & Networking",
    tags: ["repair", "turbine"],
    difficulty: "expert",
    prompt: "What is the purpose of repair in Solana’s networking?",
    choices: [
      "To allocate compute units to validators",
      "To recover missing shreds and maintain ledger continuity",
      "To sign blocks after the slot ends",
      "To change the leader schedule",
    ],
    answerIndex: 1,
    explanation:
      "Repair protocols fetch missing shreds to complete blocks and maintain ledger consistency.",
    deepDive: "This improves resilience under packet loss.",
  },
  {
    id: "Q099",
    section: "RPC & Client Behavior",
    tags: ["rpc", "indexing"],
    difficulty: "advanced",
    prompt: "Why do many production apps run their own indexers?",
    choices: [
      "Because RPC is unusable in production",
      "To build fast, app-specific queries beyond basic RPC",
      "To avoid writing on-chain programs",
      "To bypass transaction fees",
    ],
    answerIndex: 1,
    explanation: "RPC is general-purpose; indexers provide fast, domain-specific queries.",
    deepDive: "This is similar to subgraphs or custom indexers on other chains.",
  },
  {
    id: "Q100",
    section: "RPC & Client Behavior",
    tags: ["rpc", "commitment"],
    difficulty: "expert",
    prompt: "Why might ‘processed’ commitment be dangerous for user balances?",
    choices: [
      "It requires sysvar accounts",
      "It can reflect forks that are not confirmed/finalized",
      "It is slower than confirmed",
      "It costs more in RPC fees",
    ],
    answerIndex: 1,
    explanation: "Processed data can be on forks that never finalize; balances may revert.",
    deepDive: "Use confirmed/finalized for critical reads.",
  },
  {
    id: "Q101",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["feature-gates", "clusters"],
    difficulty: "advanced",
    prompt: "Why are features activated on testnet before mainnet?",
    choices: [
      "To increase fees on testnet",
      "To validate behavior under realistic conditions",
      "To reduce compute usage",
      "To bypass governance procedures",
    ],
    answerIndex: 1,
    explanation:
      "Staged activation reduces risk by validating changes under real load before mainnet.",
    deepDive: "This is standard in Solana’s rollout model.",
  },
  {
    id: "Q102",
    section: "Security & Pitfalls",
    tags: ["security", "pda"],
    difficulty: "expert",
    prompt: "Which statement about PDA “collisions” is most accurate?",
    choices: [
      "A cryptographic hash collision is feasible with enough brute force",
      "Cryptographic collisions are infeasible, but ambiguous seed schemas can still cause unintended address overlap",
      "The bump ensures uniqueness across all seed schemas",
      "The runtime inserts delimiters between seeds to prevent any overlap",
    ],
    answerIndex: 1,
    explanation:
      "A true cryptographic collision is infeasible, but developers can create practical “collisions” via ambiguous seed schemas (e.g., variable-length seeds without clear boundaries).",
    deepDive:
      "Audit rule: use explicit namespaces and unambiguous seed boundaries (fixed-size components or length-prefixing) to prevent cross-type overlap.",
  },
  {
    id: "Q103",
    section: "Security & Pitfalls",
    tags: ["security", "accounts"],
    difficulty: "advanced",
    prompt: "Why should you verify account addresses explicitly?",
    choices: [
      "To reduce compute usage per instruction",
      "To prevent account substitution attacks",
      "To increase parallelism across transactions",
      "To avoid using PDAs in state design",
    ],
    answerIndex: 1,
    explanation: "Attackers can pass arbitrary accounts; programs must enforce expected addresses.",
    deepDive: "Always check PDA derivations and owners.",
  },
  {
    id: "Q104",
    section: "Security & Pitfalls",
    tags: ["security", "init"],
    difficulty: "advanced",
    prompt: "What is a common initialization bug?",
    choices: [
      "Failing to set account data during init",
      "Re-initializing an already initialized account",
      "Using sysvars in the Accounts struct",
      "Using PDAs as authorities",
    ],
    answerIndex: 1,
    explanation: "Programs should guard against re-initialization to prevent state resets.",
    deepDive: "A discriminator or ‘is_initialized’ flag is typical.",
  },
  {
    id: "Q105",
    section: "Security & Pitfalls",
    tags: ["security", "cpi"],
    difficulty: "expert",
    prompt: "What does ‘signer privilege escalation’ mean in CPI context?",
    choices: [
      "Granting signer rights to an account that was not a signer in the outer tx",
      "Using a PDA as signer via invoke_signed",
      "Including the system program in the account list",
      "Passing extra accounts beyond what the CPI needs",
    ],
    answerIndex: 0,
    explanation:
      "Signers can’t be escalated in CPI unless the program proves PDA authority via invoke_signed.",
    deepDive: "This protects users from unauthorized signing.",
  },
  {
    id: "Q106",
    section: "Consensus, PoH & Slots",
    tags: ["consensus", "commitment"],
    difficulty: "advanced",
    prompt: "Why might you wait for finalized status when bridging or settling?",
    choices: [
      "Because finalized can still revert",
      "Because finality reduces the risk of fork reorgs",
      "Because it increases fees for bridges",
      "Because it disables CPI",
    ],
    answerIndex: 1,
    explanation: "Finalized has stronger finality and much lower reorg risk.",
    deepDive: "Critical financial operations should wait for finalized.",
  },
  {
    id: "Q107",
    section: "Consensus, PoH & Slots",
    tags: ["poh", "verification"],
    difficulty: "expert",
    prompt: "Why can PoH be verified faster than recomputed?",
    choices: [
      "Because validators skip hashes entirely",
      "Because it’s a sequential hash chain with checkpoints/entries",
      "Because it uses GPUs exclusively",
      "Because it is randomized per slot",
    ],
    answerIndex: 1,
    explanation:
      "PoH produces a sequential hash chain/clock; verifying the chained entries is efficient compared to reproducing the leader’s full production pipeline.",
    deepDive: "This enables efficient time-order verification.",
  },
  {
    id: "Q108",
    section: "Validator Pipeline & Networking",
    tags: ["leader", "mev"],
    difficulty: "expert",
    prompt: "Why can leaders influence transaction ordering?",
    choices: [
      "They can rewrite transaction signatures",
      "They choose transaction ordering within their slot",
      "They control the system program state",
      "They own all PDAs for the slot",
    ],
    answerIndex: 1,
    explanation: "Leaders decide ordering of transactions they include in their slots.",
    deepDive: "This is a source of MEV-like behavior.",
  },
  {
    id: "Q109",
    section: "Validator Pipeline & Networking",
    tags: ["qos", "spam"],
    difficulty: "advanced",
    prompt: "How does stake-weighted QoS help under spam?",
    choices: [
      "It increases compute units for all transactions",
      "It prioritizes packets from staked sources",
      "It removes priority fees during congestion",
      "It disables CPI under load",
    ],
    answerIndex: 1,
    explanation:
      "Stake-weighted QoS prefers traffic from staked validators/peers, reducing spam impact.",
    deepDive: "It’s a network-level defense.",
  },
  {
    id: "Q110",
    section: "Runtime & Parallelism",
    tags: ["runtime", "accounts"],
    difficulty: "advanced",
    prompt: "Why can two transactions touching the same writable account not run in parallel?",
    choices: [
      "Because of fee rules",
      "Because it would cause write-write conflicts",
      "Because PoH forbids parallelism",
      "Because of stake-weighted QoS",
    ],
    answerIndex: 1,
    explanation: "Write locks are exclusive; concurrent writes could break deterministic state.",
    deepDive: "Parallelism depends on non-overlapping write sets.",
  },
  {
    id: "Q111",
    section: "Token Programs",
    tags: ["tokens", "2022"],
    difficulty: "expert",
    prompt: "Why do some Token-2022 extensions complicate CPI?",
    choices: [
      "Extensions add extra required accounts and constraints",
      "Extensions remove signatures from transfers",
      "Extensions disable PDAs as authorities",
      "Extensions prevent ATAs from being used",
    ],
    answerIndex: 0,
    explanation:
      "Extensions can require extra accounts or checks (e.g., transfer hooks), affecting CPI flows.",
    deepDive: "Clients and programs must include the right extra accounts.",
  },
  {
    id: "Q112",
    section: "Fees & Compute Budget",
    tags: ["fees", "market"],
    difficulty: "advanced",
    prompt: "What’s the best way to improve landing rate during congestion?",
    choices: [
      "Increase transaction size to gain priority",
      "Add priority fee (unit price) and ensure compute budget is accurate",
      "Remove signatures to reduce fee",
      "Use sysvars to bypass scheduling",
    ],
    answerIndex: 1,
    explanation:
      "A reasonable priority fee and accurate compute budget improve inclusion likelihood.",
    deepDive: "Over-requesting compute can backfire by raising cost.",
  },
  {
    id: "Q113",
    section: "Versioned Transactions & ALTs",
    tags: ["v0", "wallets"],
    difficulty: "advanced",
    prompt: "Why might some wallets fail to sign a v0 transaction?",
    choices: [
      "They don’t support versioned transactions",
      "They require PDAs for v0",
      "They support Token-2022 but not v0 transactions",
      "They disallow sysvars in v0 messages",
    ],
    answerIndex: 0,
    explanation: "Older wallets might not support v0 transaction parsing/signing.",
    deepDive: "Most modern wallets now support v0, but compatibility matters.",
  },
  {
    id: "Q114",
    section: "Transactions & Instructions",
    tags: ["instructions", "data"],
    difficulty: "foundation",
    prompt: "Instruction data is…",
    choices: [
      "A fixed schema enforced by the runtime",
      "Arbitrary bytes interpreted by the program",
      "Always JSON encoded",
      "Always a single opcode byte",
    ],
    answerIndex: 1,
    explanation:
      "The runtime treats instruction data as opaque bytes; the program defines the schema.",
    deepDive: "This allows custom encoding strategies.",
  },
  {
    id: "Q115",
    section: "Programs & CPI",
    tags: ["programs", "logs"],
    difficulty: "foundation",
    prompt: "Program logs are best used for…",
    choices: [
      "Canonical on-chain state representation",
      "Debugging and UX hints",
      "Consensus voting data",
      "Fee collection receipts",
    ],
    answerIndex: 1,
    explanation: "Logs help debugging and UX but are not canonical state.",
    deepDive: "State lives in accounts.",
  },
  {
    id: "Q116",
    section: "Programs & CPI",
    tags: ["programs", "compute"],
    difficulty: "advanced",
    prompt: "Why can a single extra CPI break an otherwise working tx?",
    choices: [
      "It changes the recent blockhash",
      "It increases compute and account requirements",
      "It disables PDAs in the transaction",
      "It makes the transaction invalid by itself",
    ],
    answerIndex: 1,
    explanation: "CPI adds compute and often requires extra accounts; that can exceed limits.",
    deepDive: "Always budget compute and accounts for CPI chains.",
  },
  {
    id: "Q117",
    section: "Security & Pitfalls",
    tags: ["security", "account-substitution"],
    difficulty: "advanced",
    prompt: "Account substitution attacks occur when…",
    choices: [
      "Programs don’t verify expected addresses or owners",
      "Accounts are read-only in the message",
      "Programs use sysvars for metadata",
      "Programs use PDAs for authorities",
    ],
    answerIndex: 0,
    explanation: "If programs accept arbitrary accounts, attackers can substitute malicious ones.",
    deepDive: "Always validate addresses, owners, and derivations.",
  },
  {
    id: "Q118",
    section: "Security & Pitfalls",
    tags: ["security", "rent"],
    difficulty: "advanced",
    prompt: "Why should you check account data length when deserializing?",
    choices: [
      "To reduce fees paid by the transaction",
      "To avoid panics and ensure correct layout",
      "To increase compute budget for deserialization",
      "To bypass account ownership checks",
    ],
    answerIndex: 1,
    explanation: "Unexpected data length can cause deserialization errors or security issues.",
    deepDive: "Length checks prevent malformed data attacks.",
  },
  {
    id: "Q119",
    section: "RPC & Client Behavior",
    tags: ["rpc", "confirmations"],
    difficulty: "advanced",
    prompt: "Why should you re-fetch account state after a confirmed transaction?",
    choices: [
      "To update the recent blockhash",
      "To verify the actual on-chain state and handle forks",
      "To reduce fees on subsequent transactions",
      "To avoid CPI errors",
    ],
    answerIndex: 1,
    explanation: "Confirmation is not finality; re-fetch ensures you see the canonical state.",
    deepDive: "This is especially important for critical balances.",
  },
  {
    id: "Q120",
    section: "Upgrades, Feature Gates & SIMDs",
    tags: ["simd", "status"],
    difficulty: "advanced",
    prompt: "Which SIMD status most closely implies ‘live on mainnet’?",
    choices: ["Implemented", "Activated", "Accepted", "Review"],
    answerIndex: 1,
    explanation: "Activated indicates the feature gate has been turned on and is live.",
    deepDive: "Implemented only means the code exists in a release.",
  },
  {
    id: "Q121",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "pda", "security", "seeds"],
    difficulty: "advanced",
    prompt:
      'You have two PDA account types in the same program: Product uses seeds = [b"product", product_name.as_ref()], and Bid uses seeds = [product_name.as_ref(), user.key().as_ref()]. What’s the most realistic failure mode if you don’t carefully namespace/structure seeds?',
    choices: [
      "Nothing: different seed arrays always produce different PDAs",
      "An attacker can craft inputs that collide across types, blocking creation or confusing initialization flows",
      "An attacker can derive the PDA private key and sign",
      "The runtime inserts delimiters between seeds, so collisions are impossible",
    ],
    answerIndex: 1,
    explanation:
      "Seeds are processed as bytes, and variable-length parts can create ambiguous boundaries across different seed arrays. The invariant is: PDA uniqueness is only as strong as your seed schema. Use clear namespaces and unambiguous boundaries (fixed-size components or explicit length prefixes) so different account types cannot collide.",
    deepDive:
      "Seed hygiene checklist: unique static prefix per account type, avoid raw strings without length separation, prefer fixed-size components (pubkeys, hashes), and keep a stable namespace/version in the seed set.",
  },
  {
    id: "Q122",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "pda", "design", "security"],
    difficulty: "advanced",
    prompt: "Which seed design best prevents unintended collisions between different PDA types?",
    choices: [
      "Include unique static prefixes per PDA type and length-delimit any variable-length parts",
      "Use only user-controlled strings because they’re “unique enough”",
      "Reuse the same prefix everywhere for consistency",
      "Rely on bump alone for uniqueness",
    ],
    answerIndex: 0,
    explanation:
      "The invariant is that PDAs are only distinct if your seed schema makes them distinct. Unique prefixes + unambiguous boundaries prevent cross-type collisions even when user input is adversarial.",
    deepDive:
      'Practical schema: [b"type", version, fixed-size ids...] then length-delimited user strings if absolutely needed.',
  },
  {
    id: "Q123",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "remaining_accounts", "security"],
    difficulty: "advanced",
    prompt:
      "Your instruction iterates over ctx.remaining_accounts to distribute rewards. What must you assume about these accounts by default?",
    choices: [
      "Anchor applied the same constraints as in the Accounts struct",
      "They’re trusted because they were provided by the client SDK",
      "They have none of Anchor’s protections; you must validate owner, type, address/PDA, and initialization yourself",
      "They cannot be writable, so no harm is possible",
    ],
    answerIndex: 2,
    explanation:
      "Treat remaining accounts as raw, untrusted AccountInfo. The invariant is: Anchor only validates what you declared in the Accounts struct; everything else needs explicit checks.",
    deepDive:
      "Validation checklist: expected owner/program, discriminator/type, exact address or PDA derivation, initialized/liveness, and program/mint IDs for token flows.",
  },
  {
    id: "Q124",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "remaining_accounts", "tokens", "security"],
    difficulty: "advanced",
    prompt:
      "You accept a dynamic list of token accounts in remaining_accounts and transfer tokens to each. Which check would most directly prevent account-substitution theft?",
    choices: [
      "Verify each token account’s mint and that its owner matches the intended recipient from validated state, not user input",
      "Mark the list accounts as read-only",
      "Increase compute budget",
      "Use confirmed commitment instead of finalized",
    ],
    answerIndex: 0,
    explanation:
      "The invariant is: payouts must be bound to verified recipients, not to whatever accounts the caller supplies. Validate the token account’s owner/mint against trusted state and derive expected addresses when possible.",
    deepDive:
      "Design pattern: store recipient pubkeys in program state, derive ATAs from those pubkeys + mint, and verify the provided accounts match those ATAs.",
  },
  {
    id: "Q125",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "security", "program-id"],
    difficulty: "advanced",
    prompt:
      "Your Anchor instruction takes a lending_program: AccountInfo and CPI-calls it, forwarding the caller (Signer) and system_program. What’s the highest-risk assumption?",
    choices: [
      "CPI cannot escalate privileges, so this is safe",
      "If it compiles, the program is trusted",
      "If lending_program isn’t pinned, the caller can swap in a malicious program that uses the forwarded signer",
      "Only PDAs can be abused in CPI",
    ],
    answerIndex: 2,
    explanation:
      "This is a confused-deputy risk: signers remain signers during CPI, so an untrusted program can use the forwarded authority for unintended actions. The invariant is: never forward signer authority to an unverified program ID.",
    deepDive:
      "Mitigations: pin program IDs, avoid dynamic CPI targets, and minimize which signers/writable accounts you forward.",
  },
  {
    id: "Q126",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "invoke_signed", "pda", "security"],
    difficulty: "advanced",
    prompt:
      "Your program uses invoke_signed to act with a PDA authority, and the CPI target program is user-provided. Why is this especially dangerous?",
    choices: [
      "invoke_signed makes the PDA’s private key visible",
      "You are delegating PDA authority to an attacker-controlled program if the target isn’t trusted",
      "PDAs can only sign once per slot",
      "The system program rejects PDAs",
    ],
    answerIndex: 1,
    explanation:
      "invoke_signed effectively loans your PDA authority to the callee. If the target is untrusted, you’ve handed it the ability to act as your PDA within the accounts you pass.",
    deepDive:
      "Audit rule: any invoke_signed CPI with user-controlled program IDs is a red flag. Pin the target and restrict what the PDA is allowed to do.",
  },
  {
    id: "Q127",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "reload", "security"],
    difficulty: "advanced",
    prompt:
      "You CPI to token::mint_to, then immediately read ctx.accounts.mint.supply to enforce a limit. What’s the risk?",
    choices: [
      "None; Anchor account structs always reflect CPI side effects",
      "You’re reading stale deserialized data unless you reload, so the limit check can be bypassed",
      "The supply becomes finalized-only after CPI",
      "The CPI invalidates the transaction signature",
    ],
    answerIndex: 1,
    explanation:
      "Anchor caches deserialized data in Account<'info, T>. CPI mutates the underlying AccountInfo bytes, not the cached struct. The invariant: after any CPI that may mutate an account you later read, reload before using its fields.",
    deepDive:
      "Rule of thumb: CPI → read fields from the same account struct → call reload() first.",
  },
  {
    id: "Q128",
    section: "Anchor Pitfalls & Security Invariants",
    tags: ["anchor", "cpi", "reload", "audit"],
    difficulty: "advanced",
    prompt: "In code review, where should you look for missing reload() calls?",
    choices: [
      "Anywhere a CPI is followed by reads of fields from Account<'info, T> that the CPI could have changed",
      "Only in instructions that call the system program",
      "Only when using ALTs",
      "Only for read-only accounts",
    ],
    answerIndex: 0,
    explanation:
      "The auditing heuristic is simple: if a CPI can mutate an account and the code reads from its cached struct afterward, a reload is required to re-deserialize from bytes.",
    deepDive:
      "Search pattern: `CPI` then `account.field` without an intervening `account.reload()`.",
  },
];
